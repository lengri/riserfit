<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>riserfit.profiles &mdash; riserfit 0.0.2 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            riserfit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../diffusion_equations.html">Diffusion equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../licence.html">GNU GENERAL PUBLIC LICENSE</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">riserfit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">riserfit.profiles</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for riserfit.profiles</h1><div class="highlight"><pre>
<span></span><span class="c1"># type hints</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span> <span class="c1"># necessary for some typing shenanigans</span>
<span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Self</span> <span class="c1"># pre python 3.11</span>

<span class="c1">#system stuff</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">traceback</span>

<span class="c1"># data analysis, managing and calculations</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">rasterio</span> <span class="k">as</span> <span class="nn">rio</span>

<span class="c1"># imports for (non-)linear diffusion fitting</span>
<span class="kn">from</span> <span class="nn">scipy.optimize._optimize</span> <span class="kn">import</span> <span class="n">OptimizeResult</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>

<span class="c1"># for plotting stuff</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="c1"># may change backend to cairo in future, for better plots?</span>
<span class="kn">from</span> <span class="nn">matplotlib.backends.backend_pdf</span> <span class="kn">import</span> <span class="n">PdfPages</span>

<span class="c1"># library-internal functions</span>
<span class="kn">from</span> <span class="nn">.diffusion</span> <span class="kn">import</span> <span class="n">nonlin_diff_perron2011</span>
<span class="kn">from</span> <span class="nn">.dem</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.riser_maths</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1">#########################################################################</span>
<span class="c1">## Part 1: Dealing with files, file management, setting up Riser class ##</span>
<span class="c1">#########################################################################</span>

<span class="c1"># Function to open a collection of profiles</span>

<div class="viewcode-block" id="read_profile_files"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.read_profile_files">[docs]</a><span class="k">def</span> <span class="nf">read_profile_files</span><span class="p">(</span>
    <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">infiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">profilenames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">identifier</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">df_x</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;x_UTM&quot;</span><span class="p">,</span>
    <span class="n">df_y</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;y_UTM&quot;</span><span class="p">,</span>
    <span class="n">pandas_csv_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    read_profile_files: Function to open and prepare data files for terrace</span>
<span class="sd">    riser analysis. Files should be provided in .csv format and contain</span>
<span class="sd">    x, y coordinates in meters (e.g. UTM), and elevation. Multiple riser</span>
<span class="sd">    profiles may be stored in a single .csv file, as long as there is an</span>
<span class="sd">    identifier column with unique names for each individual profile.</span>
<span class="sd">    (E.g., all points are labelled as riser1-001, </span>
<span class="sd">    riser1-002, ..., riser2-001, ... The identifiers should then be &quot;riser1&quot;,</span>
<span class="sd">    &quot;riser2&quot;, etc.)</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        filepath: str</span>
<span class="sd">            Path to directory where data files with profile information are</span>
<span class="sd">            stored.</span>
<span class="sd">        infiles: list[str]</span>
<span class="sd">            List of .csv files containing profiles to be loaded.</span>
<span class="sd">        profilenames: list[str]</span>
<span class="sd">            List of profile names to be searched for in the .csv files.</span>
<span class="sd">            All rows that are assigned to a profile must contain the profile</span>
<span class="sd">            name in the identifier column.</span>
<span class="sd">        identifier: str</span>
<span class="sd">            Name of the column that contains the name of a profile listed</span>
<span class="sd">            in profilenames.</span>
<span class="sd">        df_x: str</span>
<span class="sd">            Name of column in .csv file where x coordinates of the profiles</span>
<span class="sd">            are stored.</span>
<span class="sd">        df_y: str</span>
<span class="sd">            Name of column in .csv file where y coordinates of the profiles</span>
<span class="sd">            are stored.</span>
<span class="sd">        pandas_csv_dict: dir</span>
<span class="sd">            Any arguments to be passed on to pandas.read_csv()</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        profiles: list</span>
<span class="sd">            List of pandas dataframes containing separate profiles for which</span>
<span class="sd">            data was found.</span>
<span class="sd">        profilenames: list[str]</span>
<span class="sd">            List containing all names of profiles for which data was found.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create a df for each infile</span>

    <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">infile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">infiles</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">filepath</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">infile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> 
            <span class="o">**</span><span class="n">pandas_csv_dict</span>
        <span class="p">)</span>

        <span class="c1"># use the xy_distances function</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df_x</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df_y</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">xy_distances</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span> 
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;dd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dd</span>
        <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="n">profiles</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># store separate profiles here</span>
    <span class="n">profile_not_found</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">profilenames</span><span class="p">),</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">profilenames</span><span class="p">):</span>
        <span class="c1"># for each infile, check if name is in the identifier column</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="n">identifier</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">name</span><span class="p">)):</span>
                <span class="n">profiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">file</span><span class="p">[</span><span class="n">identifier</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="n">profile_not_found</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">profilenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">profilenames</span><span class="p">)</span>  <span class="c1"># convert to np array for easier indexing</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">profile_not_found</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING: Could not find points for profiles </span><span class="si">{</span><span class="n">profilenames</span><span class="p">[</span><span class="n">profile_not_found</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">profiles</span><span class="p">,</span> <span class="n">profilenames</span><span class="p">[</span><span class="o">~</span><span class="n">profile_not_found</span><span class="p">])</span></div>


<span class="k">def</span> <span class="nf">_split_profile_GUI</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">df_x</span><span class="o">=</span><span class="s2">&quot;x_UTM&quot;</span><span class="p">,</span> <span class="n">df_y</span><span class="o">=</span><span class="s2">&quot;y_UTM&quot;</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is internal and should only be called by split_elevation_profiles().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">indexlist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">df_x</span><span class="o">=</span><span class="n">df_x</span><span class="p">,</span> <span class="n">df_y</span><span class="o">=</span><span class="n">df_y</span><span class="p">):</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">indexlist</span><span class="p">:</span>
            <span class="n">indexlist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed point with ID </span><span class="si">{</span><span class="n">ind</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">df_x</span><span class="p">],</span> <span class="n">profile</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">df_y</span><span class="p">],</span>
                        <span class="n">c</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Point ID:&quot;</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span>
                  <span class="sa">f</span><span class="s2">&quot;| </span><span class="si">{</span><span class="n">df_x</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">df_x</span><span class="p">],</span>
                  <span class="sa">f</span><span class="s2">&quot;| </span><span class="si">{</span><span class="n">df_y</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">df_y</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">profile</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">df_x</span><span class="p">],</span> <span class="n">profile</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">df_y</span><span class="p">],</span>
                        <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="n">df_x</span><span class="p">],</span> <span class="n">profile</span><span class="p">[</span><span class="n">df_y</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">picker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Easting [m]&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Northing [m]&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Select two points by clicking.&quot;</span><span class="p">)</span>
    <span class="n">fg</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="n">onpick</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Selected indices:&quot;</span><span class="p">,</span> <span class="n">indexlist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">indexlist</span>

<div class="viewcode-block" id="split_elevation_profiles"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.split_elevation_profiles">[docs]</a><span class="k">def</span> <span class="nf">split_elevation_profiles</span><span class="p">(</span>
    <span class="n">profiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">profilenames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">savedirpath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">df_x</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;x_UTM&quot;</span><span class="p">,</span>
    <span class="n">df_y</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;y_UTM&quot;</span><span class="p">,</span>
    <span class="n">df_z</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split elevation profiles into individual riser profiles using</span>
<span class="sd">    an interactive GUI. Process is saved along the way, even if the</span>
<span class="sd">    script execution is interrupted at some point. User can decide</span>
<span class="sd">    whether to split a profile via console inpute, and then select</span>
<span class="sd">    the points between which a profile should be exctracted in a </span>
<span class="sd">    plot window.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        profiles: list</span>
<span class="sd">            List of input elevation profile dfs.</span>
<span class="sd">        profilenames: list[str]</span>
<span class="sd">            List of input elevation profile names.</span>
<span class="sd">        savedirpath: str</span>
<span class="sd">            Path to subdirectory where resulting .csv files</span>
<span class="sd">            are to be saved.</span>
<span class="sd">        df_x: str</span>
<span class="sd">            Name of df column containing x coordinate values.</span>
<span class="sd">        df_y: str</span>
<span class="sd">            Name of df column containing y coordinate values</span>
<span class="sd">        df_z: str</span>
<span class="sd">            Name of df column containing elevation values</span>
<span class="sd">        verbose: bool</span>
<span class="sd">            Option to print some additional status updates </span>
<span class="sd">            to console.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        output_df_collection: list</span>
<span class="sd">            List of dfs for each individual riser profile.</span>
<span class="sd">        output_name_collection: list</span>
<span class="sd">            List of unique names for each riser profile.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">profiles</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">profilenames</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Profiles and profilenames not of equal length.&quot;</span><span class="p">)</span>
    
    <span class="c1"># check or create path to saved profiles</span>
    <span class="n">datapath</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">savedirpath</span><span class="si">}</span><span class="se">\\</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">datapath</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">datapath</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to create </span><span class="si">{</span><span class="n">datapath</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># gather all .csv files in the subdirectory</span>
    <span class="c1"># check names that exist as .csv files and are in profilenames</span>
    <span class="c1"># continue splitting profiles that are not already</span>
    <span class="c1"># saved as .csv</span>
    <span class="n">dirfiles</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">datapath</span><span class="p">)</span>
    <span class="n">dirfiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dirfiles</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">datapath</span><span class="o">+</span><span class="n">f</span><span class="p">)]</span>
    <span class="c1"># which profile names are in directory?</span>
    <span class="n">dir_file_names</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirfiles</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;r4nd0m&quot;</span> <span class="c1"># avoid empty str</span>
    <span class="n">done</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">dir_file_names</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">profilenames</span><span class="p">]</span>
    <span class="n">notdone</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">done</span><span class="p">]</span>

    <span class="n">profilenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">profilenames</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">done_profiles</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">profilenames</span><span class="p">[</span><span class="n">done</span><span class="p">])</span>
        <span class="n">notdone_profiles</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">profilenames</span><span class="p">[</span><span class="n">notdone</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found split profiles: </span><span class="si">{</span><span class="n">done_profiles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Proceeding with: </span><span class="si">{</span><span class="n">notdone_profiles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># select profiles that need to be split...</span>
    <span class="n">to_split_profiles</span> <span class="o">=</span> \
        <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">profiles</span><span class="p">)</span> <span class="k">if</span> <span class="n">notdone</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">to_split_names</span> <span class="o">=</span> <span class="n">profilenames</span><span class="p">[</span><span class="n">notdone</span><span class="p">]</span>

    <span class="n">split_profiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">split_profile_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_split_profiles</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">to_split_profiles</span><span class="p">):</span>

        <span class="c1"># show a plot with x, y coordinates</span>
        <span class="c1"># and d, z to allow user decision...</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inspecting </span><span class="si">{</span><span class="n">to_split_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> [</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="n">fg</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">df_x</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="n">df_y</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Close to proceed.&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Easting [m]&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Northing [m]&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="n">df_z</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Along-profile distance [m]&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Relative elevation [m]&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">to_split_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">split_yn</span> <span class="o">=</span> \
            <span class="nb">input</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split profile </span><span class="si">{</span><span class="n">to_split_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">? [y/n] &quot;</span><span class="p">)</span>

        <span class="c1"># easy case first... &quot;n&quot; -&gt; no action and save</span>
        <span class="k">if</span> <span class="n">split_yn</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
            
            <span class="n">split_profiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">split_profile_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_split_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datapath</span><span class="si">}{</span><span class="n">to_split_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">to_split_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> processed. Proceeding to next profile.&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">split_yn</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># may be split many times...</span>
            
            <span class="k">while</span> <span class="n">split_yn</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                
                <span class="n">ind</span> <span class="o">=</span> <span class="n">_split_profile_GUI</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">df_x</span><span class="o">=</span><span class="n">df_x</span><span class="p">,</span> <span class="n">df_y</span><span class="o">=</span><span class="n">df_y</span><span class="p">)</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># ensure correct point picking</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Selected less than two points, please retry!&quot;</span><span class="p">)</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">_split_profile_GUI</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">df_x</span><span class="o">=</span><span class="n">df_x</span><span class="p">,</span> <span class="n">df_y</span><span class="o">=</span><span class="n">df_y</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Selected more than two points, choosing endpoints!&quot;</span><span class="p">)</span>
                
                <span class="c1"># generate df with start and stop ind and save </span>
                <span class="n">df_split</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span><span class="nb">max</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">split_profiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_split</span><span class="p">)</span>
                <span class="n">split_profile_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">to_split_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">df_split</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datapath</span><span class="si">}{</span><span class="n">split_profile_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>

                <span class="c1"># again?</span>
                <span class="n">split_yn</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split stub </span><span class="si">{</span><span class="n">to_split_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> again? [y/n] &quot;</span><span class="p">)</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Console input must be y or n!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Profile </span><span class="si">{</span><span class="n">to_split_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> processed.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;All profiles processed.&quot;</span><span class="p">)</span>

    <span class="c1"># collect profiles for function return</span>
    <span class="c1"># load from datapath...</span>
    <span class="n">split_dfs</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">datapath</span><span class="p">)</span>
    <span class="n">split_dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">split_dfs</span> <span class="k">if</span> \
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datapath</span><span class="si">}{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)]</span> <span class="c1"># all csv files found.</span>
    
    <span class="c1"># select file names present in profilenames</span>
    <span class="n">output_file_collection</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">split_dfs</span><span class="p">:</span>
        <span class="n">add_to_file_output</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">profilenames</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">file</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">add_to_file_output</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">output_file_collection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> 

    <span class="n">output_df_collection</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datapath</span><span class="si">}{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> \
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">output_file_collection</span><span class="p">]</span>
    <span class="n">output_name_collection</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">output_file_collection</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">output_df_collection</span><span class="p">,</span> <span class="n">output_name_collection</span><span class="p">)</span></div>


<span class="c1"># Function to reproject profiles onto straight line, defined by lst sq fit</span>
<div class="viewcode-block" id="reproject_profiles"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.reproject_profiles">[docs]</a><span class="k">def</span> <span class="nf">reproject_profiles</span><span class="p">(</span>
    <span class="n">profiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">df_x</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;x_UTM&quot;</span><span class="p">,</span>
    <span class="n">df_y</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;y_UTM&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a list of pandas dfs containing gps profiles,</span>
<span class="sd">    performs least square reprojection and re-calculates distances.</span>
<span class="sd">    This function should only be used for profiles of individual</span>
<span class="sd">    risers!</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        profiles: list</span>
<span class="sd">            List of pandas dfs containing riser profiles.</span>
<span class="sd">        df_x: str</span>
<span class="sd">            Name of the df x coordinate column.</span>
<span class="sd">        df_y: str</span>
<span class="sd">            Name of the df y coordinate column.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        df_out: list</span>
<span class="sd">            Updated pandas dfs with reprojected profiles.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dfs_out</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">profiles</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df_x</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df_y</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

        <span class="n">x_new</span><span class="p">,</span> <span class="n">y_new</span><span class="p">,</span> <span class="n">d_new</span><span class="p">,</span> <span class="n">dd_new</span> <span class="o">=</span> \
            <span class="n">least_square_reproject</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="n">df_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_new</span>
        <span class="n">df</span><span class="p">[</span><span class="n">df_y</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_new</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_new</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;dd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dd_new</span>
        <span class="n">dfs_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dfs_out</span></div>


<div class="viewcode-block" id="center_elevation_profiles"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.center_elevation_profiles">[docs]</a><span class="k">def</span> <span class="nf">center_elevation_profiles</span><span class="p">(</span>
    <span class="n">profiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">df_z</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;z&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Automatically centers a profile close to the riser midpoint.</span>
<span class="sd">    Uses the difference in maximum and minimum elevation to</span>
<span class="sd">    find the midpoint height, and then shifts in d direction</span>
<span class="sd">    such that this point is at d=0. Any additional calibration</span>
<span class="sd">    of the profile should be done using </span>
<span class="sd">    Riser.compute_best_linear_diffusion_fit() and</span>
<span class="sd">    Riser.apply_d_z_offsets().</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        profiles: list</span>
<span class="sd">            List of pandas dfs with profile information.</span>
<span class="sd">        df_z: str</span>
<span class="sd">            Name of df column containing elevation information.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        out_profiles: list</span>
<span class="sd">            Profile dfs with updated distances and elevations.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">out_profiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">profiles</span><span class="p">:</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df_z</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">z_mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">id_mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z</span><span class="o">&lt;</span><span class="n">z_mid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># shift in z</span>
        <span class="n">z_mid</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">id_mid</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">z_mid</span>
        <span class="n">df</span><span class="p">[</span><span class="n">df_z</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>

        <span class="c1"># shift in d</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">id_mid</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

        <span class="n">out_profiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out_profiles</span></div>


<div class="viewcode-block" id="initialize_riser_class"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.initialize_riser_class">[docs]</a><span class="k">def</span> <span class="nf">initialize_riser_class</span><span class="p">(</span>
    <span class="n">profiles</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">names</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">df_x</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;x_UTM&quot;</span><span class="p">,</span>
    <span class="n">df_y</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;y_UTM&quot;</span><span class="p">,</span>
    <span class="n">df_z</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span>
    <span class="n">identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Riser&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Riser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to construct the preprocessed profiles into</span>
<span class="sd">    objects of the Riser class. Always returns one Riser class object that</span>
<span class="sd">    stores all information in lists.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        profiles: list</span>
<span class="sd">            Profiles to be initialized as Riser objects. Should be pandas</span>
<span class="sd">            dataframes.</span>
<span class="sd">        names: list</span>
<span class="sd">            Names of profiles.</span>
<span class="sd">        df_x: str</span>
<span class="sd">            Name of column in .csv files where x coordinates of the profiles</span>
<span class="sd">            are stored.</span>
<span class="sd">        df_y: str</span>
<span class="sd">            Name of column in .csv files where y coordinates of the profiles</span>
<span class="sd">            are stored.</span>
<span class="sd">        df_z: str</span>
<span class="sd">            Name of column in .csv files where z coordinates of the profiles</span>
<span class="sd">            are stored.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    Riser:</span>
<span class="sd">        Riser class object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">profiles</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of provided names does not&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; equal number of provided profiles: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">profiles</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">profile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">profiles</span><span class="p">):</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="n">df_x</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="n">df_y</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="n">df_z</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Riser</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="n">identifier</span><span class="p">)</span></div>

<span class="c1">###########################################################################</span>
<span class="c1">## Part 2: Dealing with risers, misfits, and the main Riser class itself ##</span>
<span class="c1">###########################################################################</span>

<div class="viewcode-block" id="compute_misfit_for_optimization"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.compute_misfit_for_optimization">[docs]</a><span class="k">def</span> <span class="nf">compute_misfit_for_optimization</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">d_emp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">z_emp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">scales</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">warning_eps</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use ``compute_misfit()`` instead. Only</span>
<span class="sd">    difference is the data entry format. This function is used to conform to</span>
<span class="sd">    ``scipy.optimize.minimize``, but less user friendly</span>
<span class="sd">    compared to ``compute_misfit()``.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        params: np.ndarray</span>
<span class="sd">            Array containing, in order, kt, d_off, z_off, a and b.</span>
<span class="sd">            All are scaled to one.</span>
<span class="sd">        d_emp: np.ndarray</span>
<span class="sd">            Along-profile distances.</span>
<span class="sd">        z_emp: np.ndarray</span>
<span class="sd">            Elevations of the profile.</span>
<span class="sd">        theta: float</span>
<span class="sd">            Initial riser gradient at midpoint and age zero.</span>
<span class="sd">        scales: np.ndarray</span>
<span class="sd">            The actual values for parameters listed in params.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        misfit: float</span>
<span class="sd">            Misfit value, calculated by compute_misfit().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">misfit</span> <span class="o">=</span> <span class="n">compute_misfit</span><span class="p">(</span>
        <span class="n">kt</span><span class="o">=</span><span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">d_emp</span><span class="o">=</span><span class="n">d_emp</span><span class="p">,</span>
        <span class="n">z_emp</span><span class="o">=</span><span class="n">z_emp</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="n">scales</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="n">b</span><span class="o">=</span><span class="n">scales</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
        <span class="n">theta</span><span class="o">=</span><span class="n">scales</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
        <span class="n">d_off</span><span class="o">=</span><span class="n">scales</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">z_off</span><span class="o">=</span><span class="n">scales</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">warning_eps</span><span class="o">=</span><span class="n">warning_eps</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">misfit</span></div>

<span class="k">def</span> <span class="nf">_nonlinear_t_uncertainty_mse</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">S_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">d_nl</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">warning_eps</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">z_nl_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">t_nl_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">mse_cutoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">float_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to calculate the MSE manipulated in such a way</span>
<span class="sd">    that min(MSE) = [lower_t, upper_t], i.e., the </span>
<span class="sd">    uncertainty bounds of t, assuming nonlinear diffusion.</span>
<span class="sd">    This is achieved using the transformation</span>
<span class="sd">    MSE = (MSE-mse_cutoff)**2.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        t: float</span>
<span class="sd">            Time for which misfit should be evaluated.</span>
<span class="sd">        d: np.ndarray</span>
<span class="sd">            Relative distances.</span>
<span class="sd">        z: np.ndarray</span>
<span class="sd">            Relative elevations.</span>
<span class="sd">        k: float</span>
<span class="sd">            Nonlinear diffusivity.</span>
<span class="sd">        S_c: float</span>
<span class="sd">            Critical slope.</span>
<span class="sd">        n: float</span>
<span class="sd">            Exponent of the nonlinear diffusion equation.</span>
<span class="sd">        d_nl: np.ndarray</span>
<span class="sd">            The distances used for nonlinear diffusion </span>
<span class="sd">            calculations (equally spaced).</span>
<span class="sd">        warning_eps: float</span>
<span class="sd">            Output warning if slopes are lower than this value.</span>
<span class="sd">        z_nl_matrix: np.ndarray</span>
<span class="sd">            2d numpy array of pre-computed nonlinear diffusion</span>
<span class="sd">            profiles of the form.</span>
<span class="sd">        t_nl_matrix: np.ndarray</span>
<span class="sd">            Time steps of the previously computed profiles.</span>
<span class="sd">        mse_cutoff: float</span>
<span class="sd">            Cutoff for t uncertainty interval, as in Wei et al.</span>
<span class="sd">            2015: MSE &lt; MSE_min + sigma</span>
<span class="sd">        float_multiplier: float</span>
<span class="sd">            Prevents floating point errors in scipy optimize (?).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        mse_out: float</span>
<span class="sd">            The transformed MSE at time t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># prevent negative time evals by returning high mse:</span>
    <span class="c1">#print(t&lt;0)</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mf">999.</span>
    
    <span class="c1"># check if t is in t_nl_matrix:</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t_nl_matrix</span><span class="o">==</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">z_best</span> <span class="o">=</span> <span class="n">z_nl_matrix</span><span class="p">[</span><span class="nb">id</span><span class="p">[</span><span class="mi">0</span><span class="p">],:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># get the timestep prior to t:</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t_nl_matrix</span><span class="o">&lt;</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">z_start</span> <span class="o">=</span> <span class="n">z_nl_matrix</span><span class="p">[</span><span class="nb">id</span><span class="p">,:]</span>
        <span class="c1"># run nonlinear diffusion for one time step</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">d_nl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">d_nl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="o">-</span><span class="n">t_nl_matrix</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
        <span class="n">z_1step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nonlin_diff_perron2011</span><span class="p">(</span>
            <span class="n">z_start</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">S_c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">warning_eps</span>
        <span class="p">)</span>

        <span class="n">z_best</span> <span class="o">=</span> <span class="n">z_1step</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
    
    <span class="c1"># interpolate to match spacing of d</span>
    <span class="n">intfun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">d_nl</span><span class="p">,</span> <span class="n">z_best</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
    <span class="n">z_at_t</span> <span class="o">=</span> <span class="n">intfun</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    
    <span class="c1"># calculate transformed misfit</span>

    <span class="c1"># weights</span>
    <span class="n">prof_len</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="n">f_i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">prof_len</span>
    <span class="n">f_i</span> <span class="o">*=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_i</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_i</span><span class="p">))</span>
    
    <span class="c1"># calculate mse (without root!)</span>
    <span class="n">mse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_i</span><span class="o">*</span><span class="p">((</span><span class="n">z</span><span class="o">-</span><span class="n">z_at_t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    
    <span class="c1"># shift down such that misfit is zero if mse = MSE_cutoff</span>
    <span class="c1"># ensure that 0 is local minimum. </span>
    <span class="n">mse_out</span> <span class="o">=</span> <span class="p">((</span><span class="n">mse</span><span class="o">-</span><span class="n">mse_cutoff</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">float_multiplier</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">mse_out</span>


<span class="k">def</span> <span class="nf">_linear_kt_uncertainty_mse</span><span class="p">(</span>
    <span class="n">kt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="n">a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="n">b</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="n">d</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
    <span class="n">mse_cutoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">float_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e6</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to calculate the MSE manipulated in such a way</span>
<span class="sd">    that min(MSE) = [lower_kt, upper_kt], i.e., the </span>
<span class="sd">    uncertainty bounds of kt, assuming linear diffusion.</span>
<span class="sd">    This is achieved using the transformation</span>
<span class="sd">    MSE = (MSE-mse_cutoff)**2.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        kt: float</span>
<span class="sd">            Linear diffusion age.</span>
<span class="sd">        a: float</span>
<span class="sd">            Riser height.</span>
<span class="sd">        b: float</span>
<span class="sd">            Riser far field slope.</span>
<span class="sd">        theta: float</span>
<span class="sd">            Initial slope.</span>
<span class="sd">        d: np.ndarray</span>
<span class="sd">            Relative distances.</span>
<span class="sd">        z: np.ndarray</span>
<span class="sd">            Relative elevations.</span>
<span class="sd">        mse_cutoff: float</span>
<span class="sd">            Cutoff for the kt interval as defined in </span>
<span class="sd">            Wei et al. (2015): MSE &lt; MSE_min + sigma.</span>
<span class="sd">        float_multiplier: float</span>
<span class="sd">            Prevents floating point errors in scipy optimize (?).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        mse_out: float</span>
<span class="sd">            The transformed MSE.</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print(a)</span>
    <span class="c1"># weights</span>
    <span class="n">prof_len</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="n">f_i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">prof_len</span>
    <span class="n">f_i</span> <span class="o">*=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_i</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_i</span><span class="p">))</span>
    
    <span class="c1"># best profile</span>
    <span class="n">z_best</span> <span class="o">=</span> <span class="n">analytical_profile</span><span class="p">(</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">kt</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">theta</span>
    <span class="p">)</span>
    
    <span class="c1"># calculate mse (without root!)</span>
    <span class="n">mse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_i</span><span class="o">*</span><span class="p">((</span><span class="n">z</span><span class="o">-</span><span class="n">z_best</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    
    <span class="c1"># shift down such that misfit is zero if mse = MSE_cutoff</span>
    <span class="c1"># ensure that 0 is local minimum. </span>
    <span class="n">mse_out</span> <span class="o">=</span> <span class="p">((</span><span class="n">mse</span><span class="o">-</span><span class="n">mse_cutoff</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">float_multiplier</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">mse_out</span>


<div class="viewcode-block" id="Riser"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser">[docs]</a><span class="k">class</span> <span class="nc">Riser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Riser: class containing geometrical information about risers (x, y, z, and</span>
<span class="sd">    along-profile distance). Data is stored in lists to allow for an arbitrary</span>
<span class="sd">    amount of risers to be processed at once. This class contains various </span>
<span class="sd">    methods used for calculating riser ages.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    -----------</span>
<span class="sd">        x: list[np.array]</span>
<span class="sd">            Contains x coordinates for each profile.</span>
<span class="sd">        y: list[np.array]</span>
<span class="sd">            Contains y coordinates for each profile.</span>
<span class="sd">        z: list[np.array]</span>
<span class="sd">            Contains z coordinates for each profile.</span>
<span class="sd">        d: list[np.array]</span>
<span class="sd">            Contains along-profile distances for each profile.</span>
<span class="sd">        name: list[str]</span>
<span class="sd">            Contains names for each profile.</span>
<span class="sd">        identifier: str</span>
<span class="sd">            Contains string used to identify PDFs generated by class instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">z</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>  <span class="c1"># elevations</span>
        <span class="n">d</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>  <span class="c1"># along profile distances</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>  <span class="c1"># profile name</span>
        <span class="n">identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="c1"># identify string</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialises a Riser instance and pre-defines all attributes as</span>
<span class="sd">        empty lists. This is done to achieve maximum compatibility</span>
<span class="sd">        between different instances.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            x: list[np.ndarray]</span>
<span class="sd">                x coordinates of riser profiles.</span>
<span class="sd">            y: list[np.ndarray]</span>
<span class="sd">                y coordinates of riser profiles.</span>
<span class="sd">            z: list[np.ndarray]</span>
<span class="sd">                Elevations of riser profiles.</span>
<span class="sd">            d: list[np.ndarray]</span>
<span class="sd">                Between-point distances of riser profiles.</span>
<span class="sd">            name: list[str]</span>
<span class="sd">                Profile names.</span>
<span class="sd">            identifier: str</span>
<span class="sd">                Identifier of the profiles.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            None</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># geometric properties and name tag(s)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier</span>

        <span class="c1">#############################################################</span>
        <span class="c1"># collection of class attributes that are assigned later on #</span>
        <span class="c1">#############################################################</span>

        <span class="c1"># by compute_symmetry_index()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetry_index</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_symmetry_index() stores results.&quot;&quot;&quot;</span>

        <span class="c1"># by compute_gradients()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># numerical central-difference derivate along d</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_gradients() stores results.&quot;&quot;&quot;</span>
        
        <span class="c1"># by compute_azimuth()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">azimuth</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># in rad or grad, user defined</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_azimuth() stores results.&quot;&quot;&quot;</span>
        
        <span class="c1"># by compute_best_linear_diffusion_fit()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimize_summary</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># output of scipy.optimize.minimize</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_linear_diffusion_fit() stores optimisation result.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_misfit</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># misfit for best param combination</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_linear_diffusion_fit() stores RMSE.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># diffusion age</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_linear_diffusion_fit() stores kt.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># half the initial riser height</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_linear_diffusion_fit() stores best riser height.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># far field gradient</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_linear_diffusion_fit() stores best far-field gradient.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># not optimized for, kept constant</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_linear_diffusion_fit() stores best intitial slope.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># optimal offset in horizontal direction</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_linear_diffusion_fit() stores d offset.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_z_off</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># optimal offset in vertical direction</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_linear_diffusion_fit() stores z offset.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_midpoint_grad</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># riser midpoint slope for the best fit</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_linear_diffusion_fit() stores gradient at midpoint.&quot;&quot;&quot;</span>
        
        <span class="c1"># by compute_best_nonlinear_diffusion_fit()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># best fit age</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_nonlinear_diffusion_fit() stores best t.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_opt_sum</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># output of minimize()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_nonlinear_diffusion_fit() stores optimisation result.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_z</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># save best fit z, because not easy to re-calculate</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_nonlinear_diffusion_fit() stores best-fit z matching self.d.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_z_matrix</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># save nonlin profile ast all time steps</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_nonlinear_diffusion_fit() stores z profiles at time steps dt.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_t_times</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># saves all timesteps of nonlin profile diffusion</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_nonlinear_diffusion_fit() stores all computed time steps.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_d</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># distances used by nonlin diffusion scheme</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_nonlinear_diffusion_fit() stores optimisation result.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_mf</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># minimum misfit value for nonlin fit</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_nonlinear_diffusion_fit() stores RMSE.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_dt</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># contains dt used for diffusion</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which compute_best_nonlinear_diffusion_fit() stores used dt.&quot;&quot;&quot;</span>
        
        <span class="c1"># by calculate_nonlin_t_uncertainty()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_upper_t</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which calculate_nonlin_t_uncertainty() stores upper bounds.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_lower_t</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which calculate_nonlin_t_uncertainty() stores lower bounds.&quot;&quot;&quot;</span>

        <span class="c1"># by jackknife_linear_diffusion_fit()</span>
        <span class="c1"># these lists should be nested: </span>
        <span class="c1"># [[[],[],[],...],[[],[],[],...],...]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_d</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># d values reduced by d samples</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores distances.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_z</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># z values reduced by d samples</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores elevations.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_kt</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># kt for each reduced profile</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores kt.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_a</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># a for each reduced profile</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores riser heights.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_b</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># b for each reduced profile</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores far-field slopes.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_d_off</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># slightly nsfw, d offset for red. profile</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores d offsets.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_z_off</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># z offset for reduced profile</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores z offsets.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_optimize_summary</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># summary of scipy optimization</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores optimisation summaries.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_misfit</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># best misfit values</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores RMSE.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_midpoint_gradient</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># midpoint gradients</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_linear_diffusion_fit() stores midpoint gradients.&quot;&quot;&quot;</span>

        <span class="c1"># by jackknife_nonlinear_diffusion_fit()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_jack_best_t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># best t nonlinear jackknife</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which jackknife_nonlinear_diffusion_fit() stores t.&quot;&quot;&quot;</span>
        <span class="c1"># by add_cn_ages()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cn_age</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># cosmogenic nuclide ages, if available</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which add_cn_ages() stores ages.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cn_age_sigma</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which cn_age_sigma() stores uncertainty.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cn_age_reliability</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># string describing the reliability of an age</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which cn_age_sigma() stores a reliability indicator.&quot;&quot;&quot;</span>
        
        <span class="c1"># by add_cn_terrace_age()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terrace_age</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which add_cn_terrace_age() stores ages.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terrace_age_sigma</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which add_cn_terrace_age() stores uncertainty.&quot;&quot;&quot;</span>

        <span class="c1"># by add_terrace_generation()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terrace</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which add_terrace_generation() stores the generation.&quot;&quot;&quot;</span>

        <span class="c1"># by calculate_kt_uncertainty()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_kt</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># upper uncertainty bound for kt</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which calculate_kt_uncertainty() stores an upper bound.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_kt</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># lower uncertainty bound for kt</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which calculate_kt_uncertainty() stores a lower bound.&quot;&quot;&quot;</span>

        <span class="c1"># by extract_profile_elevation()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_elevation</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># profile elevation from DEM or REM</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which extract_profile_elevation() stores an absolute elevation value.&quot;&quot;&quot;</span>

        <span class="c1"># by calculate_upstream_distance()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upstream_distance</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># distance from river base</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attribute in which calculate_upstream_distance() stores upstream_distance.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Riser.extract_subset"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.extract_subset">[docs]</a>    <span class="k">def</span> <span class="nf">extract_subset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">profiles</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Riser</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        extract_subset: Function to construct a new Riser class object with</span>
<span class="sd">        a subset of profiles from the original class instance. Use either start</span>
<span class="sd">        and stop indices or a list of profile names or indices to define the</span>
<span class="sd">        profiles to be transferred to the subset. All attributes of the original</span>
<span class="sd">        instance are preserved.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            start: int or str</span>
<span class="sd">                If of type int, position of the first profile to be subset.</span>
<span class="sd">                If of tpye str, name of the first profile to be subset.</span>
<span class="sd">            stop: int or str</span>
<span class="sd">                If of type int, position of the last profile to be subset.</span>
<span class="sd">                If of type str, name of the last profile to be subset.</span>
<span class="sd">            profiles: list of int or str</span>
<span class="sd">                List containing either the index positions or names of profiles</span>
<span class="sd">                to be subset.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            new_riser: Riser</span>
<span class="sd">                A new Riser instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make a list of indices:</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">stop</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: start, stop must be of same type.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">startID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="n">stopID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startID</span><span class="p">,</span> <span class="n">stopID</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: start, stop must be either str or int.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">profiles</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">profiles</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: profiles must be either list or None&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">profiles</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">profiles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">profiles</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">profiles</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">profiles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">p_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">p_name</span> <span class="ow">in</span> <span class="n">profiles</span><span class="p">]</span>

        <span class="c1"># create a new, empty instance of riser class:</span>

        <span class="n">new_riser</span> <span class="o">=</span> <span class="n">Riser</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># get all other attributes:</span>

        <span class="n">attribute_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attribute_keys</span><span class="p">):</span>
            <span class="n">attribute</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">attribute_subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">attribute</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">new_riser</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">attribute_subset</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_riser</span></div>

<div class="viewcode-block" id="Riser.compute_azimuth"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.compute_azimuth">[docs]</a>    <span class="k">def</span> <span class="nf">compute_azimuth</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span> 
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the profile orientation relative to north. </span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            rad: bool</span>
<span class="sd">                Angles are returned in rad. If False, returned in </span>
<span class="sd">                degrees.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">azs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">])</span>

            <span class="n">dot</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Dot product between [x1, y1] and [x2, y2]</span>
            <span class="n">det</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Determinant</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">det</span><span class="p">,</span> <span class="n">dot</span><span class="p">)</span>  
            <span class="k">if</span> <span class="n">rad</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">*=</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> 
            <span class="n">azs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">azimuth</span> <span class="o">=</span> <span class="n">azs</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Riser.flip_profile_orientation"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.flip_profile_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">flip_profile_orientation</span><span class="p">(</span>
        <span class="bp">self</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to ensure that each d and z are ordered such</span>
<span class="sd">        that d[0] &lt; d[-1] and z[0] &lt; z[-1]. Also reverses the ordering</span>
<span class="sd">        in x and y. This is important for symmetry calculations and</span>
<span class="sd">        general data fitting.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            None</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if z[0] &lt; z[-1]. If yes, done. If not, flip.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># x, y might be empty in some cases...</span>
                <span class="n">xy_empty</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">True</span>
                <span class="c1"># flip x, y, z, (d)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">xy_empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># calculate d from scratch:</span>
                <span class="n">d_new</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xy_distances</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="c1"># re-center z, just to be sure...</span>
                <span class="n">z_mid</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">id_mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">z_mid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># shift in z</span>
                <span class="n">z_mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">id_mid</span><span class="p">]</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">z_mid</span>
                
                <span class="c1"># shift in d</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_new</span> <span class="o">-</span> <span class="n">d_new</span><span class="p">[</span><span class="n">id_mid</span><span class="p">]</span>
            
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.compute_symmetry_index"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.compute_symmetry_index">[docs]</a>    <span class="k">def</span> <span class="nf">compute_symmetry_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the RMSE between the lower and upper &quot;legs&quot; of the</span>
<span class="sd">        riser. The midpoint, or point of rotation, is defined at d=0.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Whether to output a PDF containing symmetry index results.</span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Whether to print symmetry indices to the console.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">summarypdf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">PdfPages</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_symmetry_summary.pdf&quot;</span><span class="p">)</span>

        <span class="n">symm_index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">summarypdf</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Printing symmetry summary PDF to </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> 
                <span class="n">end</span><span class="o">=</span><span class="s2">&quot;... &quot;</span><span class="p">,</span> 
                <span class="n">flush</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
            <span class="n">d_neg</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span><span class="p">[</span><span class="n">d</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">z_neg</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>


            <span class="n">intfun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">d_neg</span><span class="p">,</span> <span class="n">z_neg</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
            <span class="n">d_inds</span> <span class="o">=</span> \
                <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">d_neg</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="ow">and</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">d_neg</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">else</span> <span class="kc">False</span>\
                <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
            <span class="n">z_int</span> <span class="o">=</span> <span class="n">intfun</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d_inds</span><span class="p">])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#a = 1</span>
            <span class="n">error</span> <span class="o">=</span> \
                <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d_inds</span><span class="p">]</span><span class="o">-</span><span class="n">z_int</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> \
                <span class="nb">len</span><span class="p">(</span><span class="n">z_int</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">summarypdf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>

                <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d_neg</span><span class="p">,</span> <span class="n">z_neg</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;rotated&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d_inds</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d_inds</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">)</span>
                <span class="c1">#ax[0].plot(d[d_inds], z_int, c=&quot;black&quot;, label=&quot;int&quot;,</span>
                <span class="c1">#    linestyle=&quot;dashed&quot;)</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SE = </span><span class="si">{</span><span class="n">error</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">fg</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">symm_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">symmetry_index</span> <span class="o">=</span> <span class="n">symm_index</span>
        <span class="k">if</span> <span class="n">summarypdf</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.compute_gradients"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.compute_gradients">[docs]</a>    <span class="k">def</span> <span class="nf">compute_gradients</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute_gradients: Function to compute the numerical gradient for each</span>
<span class="sd">        profile point based on the along-profile distance d and elevation z.</span>
<span class="sd">        The centered derivative is calculated for all points except for the</span>
<span class="sd">        first and last one. For the latter, the forwards/backwards derivative is</span>
<span class="sd">        calculated instead.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Option to create a PDF in the working directory.</span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Option to output a message when creating PDF.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grads</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x_coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
            <span class="n">y_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_coord</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">y_coord</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> \
                     <span class="p">(</span><span class="n">x_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_coord</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_coord</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">first</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_coord</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_coord</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_coord</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_coord</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">first</span><span class="p">],</span> <span class="n">center</span><span class="p">,</span> <span class="p">[</span><span class="n">last</span><span class="p">]))</span>
            <span class="n">grads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span> <span class="o">=</span> <span class="n">grads</span>

        <span class="c1"># create a summary pdf if wanted</span>

        <span class="k">if</span> <span class="n">summarypdf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Creating gradient summary PDF&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;... &quot;</span><span class="p">)</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">PdfPages</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_gradient_summary.pdf&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

                <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="c1"># compute and plot smooth gradient (10% window width)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="mf">0.1</span><span class="p">)</span>

                <span class="n">smooth_grad</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;same&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">smooth_grad</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Gradient [m/m]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Along-profile distance [m]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">])</span>
                <span class="n">fg</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.apply_d_z_offsets"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.apply_d_z_offsets">[docs]</a>    <span class="k">def</span> <span class="nf">apply_d_z_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to recalculate d, z using the best fit</span>
<span class="sd">        offsets determined by the linear diffusion fit.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            None</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            None</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if best_d_off, best_z_off are present:</span>

        <span class="n">checks</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span> <span class="o">==</span> <span class="p">[],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_z_off</span> <span class="o">==</span> <span class="p">[]]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">checks</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;self.best_d_off or self.best_z_off are empty.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dists</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dists</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_z_off</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Riser.mirror_upper_profile_half"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.mirror_upper_profile_half">[docs]</a>    <span class="k">def</span> <span class="nf">mirror_upper_profile_half</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">apply_to_selection</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">symmetry_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">,</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes the upper half of each riser profile</span>
<span class="sd">        (defined by d&gt;0) and rotates it in such a way that it </span>
<span class="sd">        replaces the lower half of the profile. This is</span>
<span class="sd">        equivalent to a rotation of 180° around the coordinate</span>
<span class="sd">        origin. By default, it is applied to all profiles with a </span>
<span class="sd">        symmetry index greater than 4.5.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            apply_to_selection: list</span>
<span class="sd">                If not None (default), a list of length equal to number</span>
<span class="sd">                of profiles containing True/False entries.</span>
<span class="sd">                If entry is True, the profile corresponding to the index</span>
<span class="sd">                is mirrored.</span>
<span class="sd">            symmetry_threshold: float</span>
<span class="sd">                All profiles with a SE greater than the threshold are</span>
<span class="sd">                mirrored. Set to 0.</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Option to print a summary PDF.</span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Print status updates.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute symmetry index if not yet done:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry_index</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_symmetry_index</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">summarypdf</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving summary PDF to </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">PdfPages</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_mirrored_profiles.pdf&quot;</span><span class="p">)</span>
        
        <span class="n">typecheck</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">apply_to_selection</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">typecheck</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">id_check</span> <span class="o">=</span> <span class="n">apply_to_selection</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">id_check</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">id_check</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">symmetry_threshold</span><span class="p">:</span>

                <span class="c1"># calculate the distance of all points to the origin</span>
                <span class="n">dz_points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
                <span class="n">dz_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">dz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">dz</span> <span class="ow">in</span> <span class="n">dz_points</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">dz_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dz_dists</span><span class="p">)</span>
                <span class="n">d_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">dz_min</span><span class="p">]</span>
                <span class="n">z_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">dz_min</span><span class="p">]</span>

                <span class="c1"># shift all points by d_min, z_min</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">d_min</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">z_min</span> 

                <span class="n">d_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">z_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">d_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="o">-</span><span class="n">d_pos</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_pos</span><span class="p">))</span>
                <span class="n">z_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="o">-</span><span class="n">z_pos</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">z_pos</span><span class="p">))</span> 

                <span class="k">if</span> <span class="n">summarypdf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d_new</span><span class="p">,</span> <span class="n">z_new</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">d_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">z_min</span><span class="p">,</span>
                        <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span>
                    <span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
                    <span class="n">fg</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_new</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_new</span>
        <span class="c1">#print(self.d[2])</span>
        <span class="c1">#print(self.z[2])</span>

        <span class="k">if</span> <span class="n">summarypdf</span><span class="p">:</span> 
            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Riser.compute_best_linear_diffusion_fit"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.compute_best_linear_diffusion_fit">[docs]</a>    <span class="k">def</span> <span class="nf">compute_best_linear_diffusion_fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">init_kt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.</span><span class="p">,</span>
        <span class="n">init_a</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">init_b</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">init_theta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">init_d_off</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">init_z_off</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">kt_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10000</span><span class="p">),</span>
        <span class="n">a_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">b_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">theta_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span>
        <span class="n">d_off_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
        <span class="n">z_off_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">warning_eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-10</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses scipy&#39;s ``optimize.minimize`` to</span>
<span class="sd">        compute a set of parameters leading to a best fit between the analytical</span>
<span class="sd">        linear diffusion profile and the measured profile defined by self.d and</span>
<span class="sd">        self.z. Initial guesses may be user defined and can lead to</span>
<span class="sd">        significantly different results. Initial guesses should not equal zero.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            init_kt: float</span>
<span class="sd">                Initial guess for diffusion age.</span>
<span class="sd">            init_a:</span>
<span class="sd">                Initial guess for the riser height. By default (None) computed</span>
<span class="sd">                as ``(self.z[i].max() - self.z[i].min()) / 2``.</span>
<span class="sd">            init_b: float</span>
<span class="sd">                Initial guess for the far field gradient.</span>
<span class="sd">            init_theta: float</span>
<span class="sd">                Initial value for the initial gradient at the riser midpoint and</span>
<span class="sd">                age zero. This value can only be robustly estimated for some</span>
<span class="sd">                risers, especially those that have retained a slope of theta</span>
<span class="sd">                around their midpoints. For other risers, this value can vary </span>
<span class="sd">                drastically.</span>
<span class="sd">            init_d_off: float</span>
<span class="sd">                Initial guess for the offset in along-profile (horizontal)</span>
<span class="sd">                direction.</span>
<span class="sd">            init_z_off: float</span>
<span class="sd">                Initial guess for the offset in elevation (vertical) direction.</span>
<span class="sd">            kt_range: tuple</span>
<span class="sd">                Bounds of diffusion ange range to be considered by the</span>
<span class="sd">                optimization alogrithm.</span>
<span class="sd">            a_range: tuple</span>
<span class="sd">                Bounds of the (half) riser height to be considered by the</span>
<span class="sd">                optimization algorithm.</span>
<span class="sd">            b_range: tuple</span>
<span class="sd">                Bounds of the far field gradient to be considered by the</span>
<span class="sd">                optimization algorithm.</span>
<span class="sd">            theta_range: tuple</span>
<span class="sd">                Bounds for the initial slope to be considered by the optimization</span>
<span class="sd">                algorithm.</span>
<span class="sd">            d_off_range: tuple</span>
<span class="sd">                Bounds of the offset in along-profile (horizontal) direction to</span>
<span class="sd">                be considered by the optimization algorithm.</span>
<span class="sd">            z_off_range: tuple</span>
<span class="sd">                Bounds of the offset in elevation (vertical) direction to be</span>
<span class="sd">                considered by the optimization algorithm.</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Option to create a summary PDF containing best fits for each</span>
<span class="sd">                profile.</span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Option to print the best fit parameters to the console.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#self.best_theta = [init_theta for ind in self.name]  # constant</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>  <span class="c1"># initial scaled guesses</span>

        <span class="c1"># initialize lists for storing results</span>

        <span class="n">opt_sum</span><span class="p">,</span> <span class="n">b_kt</span><span class="p">,</span> <span class="n">b_d_off</span><span class="p">,</span> <span class="n">b_z_off</span><span class="p">,</span> <span class="n">b_a</span><span class="p">,</span> <span class="n">b_b</span><span class="p">,</span> <span class="n">b_theta</span><span class="p">,</span> <span class="n">b_mf</span><span class="p">,</span> <span class="n">b_grad</span> <span class="o">=</span> \
            <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>


        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
            
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">init_a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">init_a1</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># initial guess for a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">init_a1</span> <span class="o">=</span> <span class="n">init_a</span>
            
            <span class="k">if</span> <span class="n">a_range</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span> 
                <span class="n">a_range1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">init_a1</span><span class="p">,</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">init_a1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a_range1</span> <span class="o">=</span> <span class="n">a_range</span>

            <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">kt_range</span><span class="p">,</span> <span class="n">d_off_range</span><span class="p">,</span> <span class="n">z_off_range</span><span class="p">,</span> <span class="n">a_range1</span><span class="p">,</span> <span class="n">b_range</span><span class="p">,</span> <span class="n">theta_range</span><span class="p">)</span>
            <span class="n">scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">init_kt</span><span class="p">,</span> <span class="n">init_d_off</span><span class="p">,</span> <span class="n">init_z_off</span><span class="p">,</span> <span class="n">init_a1</span><span class="p">,</span> <span class="n">init_b</span><span class="p">,</span> <span class="n">init_theta</span><span class="p">])</span>

            <span class="c1"># check if bounds have correct format</span>
            <span class="n">bound_length</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">bound_length</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: Not all bounds are tuples of length two.&quot;</span><span class="p">)</span>

            <span class="c1"># check if any initial guesses are zero</span>
            <span class="c1"># cannot divide by zero to scale...</span>
            <span class="n">inits</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_kt</span><span class="p">,</span> <span class="n">init_d_off</span><span class="p">,</span> <span class="n">init_z_off</span><span class="p">,</span> <span class="n">init_a1</span><span class="p">,</span> <span class="n">init_b</span><span class="p">,</span> <span class="n">init_theta</span><span class="p">]</span>
            <span class="n">inits_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inits</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">inits_val</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: Initial parameter guess with zero-value.&quot;</span><span class="p">)</span>


            <span class="n">scaled_bounds</span> <span class="o">=</span> \
                <span class="nb">tuple</span><span class="p">((</span><span class="n">lb</span> <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">lb</span> <span class="o">/</span> <span class="n">scales</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ub</span> <span class="k">if</span> <span class="n">ub</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ub</span> <span class="o">/</span> <span class="n">scales</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounds</span><span class="p">))</span>

            <span class="c1"># sys.exit()</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing best fit for profile </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">fit_profile</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                <span class="n">fun</span><span class="o">=</span><span class="n">compute_misfit_for_optimization</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">warning_eps</span><span class="p">),</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Powell&quot;</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">scaled_bounds</span>
            <span class="p">)</span>

            <span class="c1"># save summary</span>
            <span class="n">opt_sum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_profile</span><span class="p">)</span>
            <span class="c1"># save best-fit parameters</span>
            <span class="n">b_kt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_profile</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">scales</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">b_d_off</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_profile</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">scales</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">b_z_off</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_profile</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">scales</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">b_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_profile</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">scales</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">b_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_profile</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">scales</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">b_theta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_profile</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">scales</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
            <span class="c1"># save best-fit misfit</span>
            <span class="n">b_mf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_profile</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span>
            <span class="c1"># calculate midpoint gradient for best fit:</span>
            <span class="n">b_grad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">analytical_derivative</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b_kt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">b_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">b_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">b_theta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Best fit parameters:&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  kt: </span><span class="si">{</span><span class="n">b_kt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  d_off: </span><span class="si">{</span><span class="n">b_d_off</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  z_off: </span><span class="si">{</span><span class="n">b_z_off</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  a: </span><span class="si">{</span><span class="n">b_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  b: </span><span class="si">{</span><span class="n">b_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  theta: </span><span class="si">{</span><span class="n">b_theta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  RMSE: </span><span class="si">{</span><span class="n">b_mf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span>
                      <span class="p">)</span>

        <span class="c1"># save lists to attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimize_summary</span> <span class="o">=</span> <span class="n">opt_sum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_misfit</span> <span class="o">=</span> <span class="n">b_mf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span> <span class="o">=</span> <span class="n">b_kt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span> <span class="o">=</span> <span class="n">b_a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span> <span class="o">=</span> <span class="n">b_b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span> <span class="o">=</span> <span class="n">b_theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span> <span class="o">=</span> <span class="n">b_d_off</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_z_off</span> <span class="o">=</span> <span class="n">b_z_off</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_midpoint_grad</span> <span class="o">=</span> <span class="n">b_grad</span>

        <span class="k">if</span> <span class="n">summarypdf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Printing summary PDF to </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;... &quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">PdfPages</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_linear_diffusion_summary.pdf&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>
                <span class="n">z_emp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">d_emp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">z_ana</span> <span class="o">=</span> <span class="n">analytical_profile</span><span class="p">(</span>
                    <span class="n">d_emp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">kt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">theta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d_emp</span><span class="p">,</span> <span class="n">z_emp</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dotted&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Unadjusted profile&quot;</span><span class="p">)</span>  <span class="c1"># original profile</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d_emp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">z_emp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_z_off</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Shifted profile&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d_emp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">z_ana</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Best fit profile&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;darkgray&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Along-profile distance [m]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Relative elevation [m]&quot;</span><span class="p">)</span>

                <span class="n">plot_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;kt = </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
                            <span class="sa">f</span><span class="s2">&quot;a = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
                            <span class="sa">f</span><span class="s2">&quot;b = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
                            <span class="sa">fr</span><span class="s2">&quot;$\theta = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">$&quot;</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">d_off = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
                            <span class="sa">f</span><span class="s2">&quot;z_off = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">best_z_off</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> \
                            <span class="sa">f</span><span class="s2">&quot;RMSE = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">best_misfit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">plot_text</span><span class="p">,</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                    <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

                <span class="n">fg</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.compute_best_nonlinear_diffusion_fit"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.compute_best_nonlinear_diffusion_fit">[docs]</a>    <span class="k">def</span> <span class="nf">compute_best_nonlinear_diffusion_fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">t_range</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">S_c</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">init_dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">interp_dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">interp_method</span> <span class="o">=</span> <span class="s2">&quot;cubic&quot;</span><span class="p">,</span>
        <span class="n">warning_eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">10e-15</span><span class="p">,</span>
        <span class="n">save_tz</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute_best_nonlinear_diffusion_fit: Calculate the best-fit age for</span>
<span class="sd">        all profiles contained in the Riser instance. Assumes that ``S_c`` and ``k``</span>
<span class="sd">        do not vary between profiles. This method uses the implicit scheme</span>
<span class="sd">        based on Perron (2011).</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            t_range: list</span>
<span class="sd">                List of age boundary tuples. If list is empty,</span>
<span class="sd">                upper boundaries are set to self.best_kt[i]*2.</span>
<span class="sd">            k: float</span>
<span class="sd">                Diffusivity constant in the nonlinear diffusion equation,</span>
<span class="sd">                in m^2 / kyr</span>
<span class="sd">            S_c: float</span>
<span class="sd">                Critical hillslope gradient.</span>
<span class="sd">            init_dt: float</span>
<span class="sd">                Time step size for the implicit nonlinear diffusion scheme.</span>
<span class="sd">            interp_dx: float</span>
<span class="sd">                Resolution size for the profile grid used in the implicit</span>
<span class="sd">                scheme. Smaller dx will increase computation time, but avoid</span>
<span class="sd">                interpolation errors when comparing the modelled profile to the</span>
<span class="sd">                measured profile.</span>
<span class="sd">            warning_eps: float</span>
<span class="sd">                If calculated slope is less than warning_eps, warning is raised.</span>
<span class="sd">                Necessary, because negative slopes occur due to floating point</span>
<span class="sd">                errors.</span>
<span class="sd">            save_tz: bool</span>
<span class="sd">                Option to save t and z at every timestep of the numerical modeling.</span>
<span class="sd">                May result in significantly larger memory usage.</span>
<span class="sd">            interp_method: str or float</span>
<span class="sd">                Method used for interpolating the modelled profile to the points</span>
<span class="sd">                where elevation was measured. See scipy&#39;s interp1d for details.</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Option to print a summmary pdf containing age estimates for each</span>
<span class="sd">                profile.</span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Option to print process updates to the console while ages are</span>
<span class="sd">                calculated.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>



        <span class="c1"># check if best_a, best_b are defined</span>
        <span class="n">to_check</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">]</span>
        <span class="n">checks</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="o">==</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">to_check</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">checks</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;a, b or theta not defined. </span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Run compute_best_linear_diffusion_fit before this.&quot;</span><span class="p">)</span>

        <span class="c1"># a function that takes as input an age, the z_nl, t_nl matrix etc.</span>
        <span class="c1"># computes the nonlinear implicit diffusion and returns the misfit</span>
        <span class="c1"># at that age with respect to the measured profile.</span>

        <span class="k">def</span> <span class="nf">misfit_nonlin_diff</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">9999</span>

            <span class="c1"># unpack the parameters</span>
            <span class="n">d_nonlin</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">z_matrix</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">z_time</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">z_profile</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># the measured profile.</span>
            <span class="n">d_profile</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># the distance values of the measured profile</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
            <span class="n">S_c</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
            <span class="n">interp_method</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>

            <span class="c1"># if time is in z_time, compute the misfit right away</span>
            <span class="k">if</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">z_time</span><span class="p">:</span>

                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z_time</span><span class="o">==</span><span class="n">time</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">interp_fun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">,</span> <span class="n">z_matrix</span><span class="p">[</span><span class="n">ind</span><span class="p">,:],</span> <span class="n">interp_method</span><span class="p">)</span>
                <span class="n">z_interp</span> <span class="o">=</span> <span class="n">interp_fun</span><span class="p">(</span><span class="n">d_profile</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># get next-youngest time step and calculate nonlin diff</span>
                <span class="c1"># from there.</span>

                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z_time</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># last age &lt; time</span>
                <span class="n">new_dt</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">z_time</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

                <span class="c1"># calculate 1 nonlinear diffusion step using new_dt</span>

                <span class="n">z_at_time</span><span class="p">,</span> <span class="n">t_at_time</span> <span class="o">=</span> <span class="n">nonlin_diff_perron2011</span><span class="p">(</span>
                    <span class="n">z_matrix</span><span class="p">[</span><span class="n">ind</span><span class="p">,:],</span>
                    <span class="n">dx</span><span class="p">,</span>
                    <span class="n">new_dt</span><span class="p">,</span>
                    <span class="mi">1</span><span class="p">,</span> <span class="c1"># only need one time step to reach requested time</span>
                    <span class="n">k</span><span class="p">,</span>
                    <span class="n">S_c</span><span class="p">,</span>
                    <span class="n">n</span><span class="p">,</span>
                    <span class="n">warning_eps</span><span class="o">=</span><span class="n">warning_eps</span>
                <span class="p">)</span>

                <span class="c1"># interpolate</span>
                <span class="n">interp_fun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">,</span> <span class="n">z_at_time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">interp_method</span><span class="p">)</span>
                <span class="n">z_interp</span> <span class="o">=</span> <span class="n">interp_fun</span><span class="p">(</span><span class="n">d_profile</span><span class="p">)</span>

            <span class="c1"># compute misfit for z_interp and z_profile</span>

            <span class="c1"># compute weights</span>

            <span class="n">prof_len</span> <span class="o">=</span> <span class="n">d_profile</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_profile</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">f_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_interp</span><span class="p">))</span>
            <span class="n">f_i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_profile</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">d_profile</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">prof_len</span>
            <span class="n">f_i</span> <span class="o">*=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_i</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_i</span><span class="p">))</span>
            <span class="c1"># compute misfit</span>

            <span class="n">rmse</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_i</span><span class="o">*</span><span class="p">((</span><span class="n">z_interp</span><span class="o">-</span><span class="n">z_profile</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">z_profile</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">rmse</span>

        <span class="c1"># set upper age boundaries if t_range = []</span>

        <span class="k">if</span> <span class="n">t_range</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">t_range</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kt</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">kt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">]</span>

        <span class="n">summaries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">best_ts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">best_z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">best_mf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t_save</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># save each timestep</span>
        <span class="n">z_save</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># save profile at each timestep</span>
        <span class="n">d_nonlin_save</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># x values for nonlinear diffusion</span>
        <span class="n">nonlin_dt</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_dt</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>

            <span class="c1"># first guess for t</span>
            <span class="n">init_t_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating age for profile </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Upper t set to </span><span class="si">{</span><span class="n">t_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> kyr&quot;</span><span class="p">)</span>

            <span class="c1"># estimate needed profile length</span>
            <span class="n">riser_baselength</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">d_length</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">riser_baselength</span>

            <span class="c1"># check if d_length is longer than measured profile length</span>
            <span class="c1"># if not, use the profile length instead.</span>
            <span class="k">if</span> <span class="n">d_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)):</span>
                <span class="n">d_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

            <span class="n">d_nonlin</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">d_length</span><span class="p">,</span> <span class="n">d_length</span><span class="o">+</span><span class="n">interp_dx</span><span class="p">,</span> <span class="n">interp_dx</span><span class="p">)</span>
            <span class="n">z_init</span> <span class="o">=</span> <span class="n">analytical_profile</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># run the nonlinear diffusion process with the specified dt</span>

            <span class="n">z_nl</span><span class="p">,</span> <span class="n">t_nl</span> <span class="o">=</span> <span class="n">nonlin_diff_perron2011</span><span class="p">(</span>
                <span class="n">z_init</span><span class="p">,</span>
                <span class="n">interp_dx</span><span class="p">,</span>
                <span class="n">init_dt</span><span class="p">,</span>
                <span class="n">n_t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">t_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">init_dt</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                <span class="n">S_c</span><span class="o">=</span><span class="n">S_c</span><span class="p">,</span>
                <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                <span class="n">warning_eps</span><span class="o">=</span><span class="n">warning_eps</span>
            <span class="p">)</span>

            <span class="c1"># build params list for misfit function</span>

            <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span>
                <span class="n">d_nonlin</span><span class="p">,</span>
                <span class="n">z_nl</span><span class="p">,</span>
                <span class="n">t_nl</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">interp_dx</span><span class="p">,</span>
                <span class="n">k</span><span class="p">,</span>
                <span class="n">S_c</span><span class="p">,</span>
                <span class="n">n</span><span class="p">,</span>
                <span class="n">interp_method</span>
            <span class="p">])</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>  <span class="c1"># necessary formatting because of the way</span>
            <span class="c1"># minizmize passes params into the misfit function</span>

            <span class="n">fit_time</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                <span class="n">fun</span><span class="o">=</span><span class="n">misfit_nonlin_diff</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">init_t_i</span><span class="p">]),</span>
                <span class="n">args</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Powell&quot;</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">t_range</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span>
            <span class="p">)</span>

            <span class="n">summaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_time</span><span class="p">)</span>
            <span class="n">best_ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_time</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">best_mf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_time</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span>
            <span class="n">d_nonlin_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">)</span>

            <span class="c1"># save the best fit profile</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t_nl</span> <span class="o">&lt;</span> <span class="n">fit_time</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">z_onestep</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nonlin_diff_perron2011</span><span class="p">(</span>
                <span class="n">z_nl</span><span class="p">[</span><span class="n">ind</span><span class="p">,:],</span>
                <span class="n">interp_dx</span><span class="p">,</span>
                <span class="n">fit_time</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">t_nl</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>
                <span class="n">n_t</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                <span class="n">S_c</span><span class="o">=</span><span class="n">S_c</span><span class="p">,</span>
                <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                <span class="n">warning_eps</span><span class="o">=</span><span class="n">warning_eps</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">save_tz</span><span class="p">:</span>
                <span class="c1"># save all timesteps (including best fit)</span>
                <span class="n">t_s</span> <span class="o">=</span> <span class="n">t_nl</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">t_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_s</span><span class="p">,</span> <span class="n">fit_time</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="c1"># save all profiles (including best fit)</span>
                <span class="n">z_s</span> <span class="o">=</span> <span class="n">z_nl</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span>
                <span class="n">z_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">z_s</span><span class="p">,</span> <span class="n">z_onestep</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1">#interpolate</span>
            <span class="n">interp_fun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">,</span> <span class="n">z_onestep</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">interp_method</span><span class="p">)</span>
            <span class="n">best_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interp_fun</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Best fit age: </span><span class="si">{</span><span class="n">best_ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> kyr&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_opt_sum</span> <span class="o">=</span> <span class="n">summaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span> <span class="o">=</span> <span class="n">best_ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_z</span> <span class="o">=</span> <span class="n">best_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_mf</span> <span class="o">=</span> <span class="n">best_mf</span>
        <span class="k">if</span> <span class="n">save_tz</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_z_matrix</span> <span class="o">=</span> <span class="n">z_save</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_t_times</span> <span class="o">=</span> <span class="n">t_save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_d</span> <span class="o">=</span> <span class="n">d_nonlin_save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_dt</span> <span class="o">=</span> <span class="n">nonlin_dt</span>

        <span class="k">if</span> <span class="n">summarypdf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># pdf of best fit curve and profile for each profile</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating summary PDF ...&quot;</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">PdfPages</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_nonlinear_diffusion_summary.pdf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

                <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Measured profile&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Best fit profile&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Relative distance [m]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Relative elevation [m]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;t = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> kyr&quot;</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;darkgray&quot;</span><span class="p">)</span>

                <span class="n">fg</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Riser.compute_best_nonlinear_diffusion_fit_general"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.compute_best_nonlinear_diffusion_fit_general">[docs]</a>    <span class="k">def</span> <span class="nf">compute_best_nonlinear_diffusion_fit_general</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">diffusion_law</span><span class="p">:</span> <span class="nb">callable</span><span class="p">,</span>
        <span class="n">t_range</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">init_dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">interp_dx</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">diff_arg_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">interp_method</span> <span class="o">=</span> <span class="s2">&quot;cubic&quot;</span><span class="p">,</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that takes any differentiable diffusion law, in form</span>
<span class="sd">        equal to ``riserfit.nonlin_diff_perron2011`` </span>
<span class="sd">        and performs a fitting routine.</span>
<span class="sd">        Any special arguments of the diffusion law (e.g., critical</span>
<span class="sd">        slope) are supplied in the diff_arg_dict dictionary.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            diffusion_law: callable</span>
<span class="sd">                A function like ``riserfit.nonlin_diff_perron2011`` that</span>
<span class="sd">                calculates the diffusion of a riser profile and outputs</span>
<span class="sd">                a ``np.ndarray`` containing elevation values of every time step</span>
<span class="sd">                and a second ``np.ndarray`` containing the cumulative time of the</span>
<span class="sd">                time steps.</span>
<span class="sd">                The function must at minimum take initial elevations,</span>
<span class="sd">                dx, dt, number of time steps, and k as inputs. Any</span>
<span class="sd">                additional parameters may be passed by ``diff_arg_dict``.</span>
<span class="sd">            t_range: list</span>
<span class="sd">                List of upper t boundaries for each profile.</span>
<span class="sd">            k: float</span>
<span class="sd">                The diffusivity constant of the nonlinear diffusion model.</span>
<span class="sd">            init_dt: float</span>
<span class="sd">                Size of the time step used for numerical calculations.</span>
<span class="sd">            interp_dx: float</span>
<span class="sd">                Distance between z grid nodes of the modelled profile.</span>
<span class="sd">            diff_arg_dict: dict</span>
<span class="sd">                Additional arguments passed on to diffusion_law.</span>
<span class="sd">            interp_method: </span>
<span class="sd">                Interpolation method used in scipy.interpolate.interp1d.</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Option to compile a summary PDF.</span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Option to print status messages to the console.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">nonlin_misfit_general</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span> <span class="n">diffusion_function</span><span class="p">,</span> <span class="n">d_nonlin</span><span class="p">,</span> <span class="n">z_nl</span><span class="p">,</span> <span class="n">t_nl</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> 
            <span class="n">interp_dx</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">interp_method</span><span class="p">,</span> <span class="n">diff_arg_dict</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">9999</span>

            <span class="k">if</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">t_nl</span><span class="p">:</span>

                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t_nl</span><span class="o">==</span><span class="n">time</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">interp_fun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">,</span> <span class="n">z_nl</span><span class="p">[</span><span class="n">ind</span><span class="p">,:],</span> <span class="n">interp_method</span><span class="p">)</span>
                <span class="n">z_interp</span> <span class="o">=</span> <span class="n">interp_fun</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># get next-youngest time step and calculate nonlin diff</span>
                <span class="c1"># from there.</span>

                <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t_nl</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># last age &lt; time</span>
                <span class="n">new_dt</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">t_nl</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

                <span class="c1"># calculate 1 nonlinear diffusion step using new_dt</span>

                <span class="n">z_at_time</span><span class="p">,</span> <span class="n">t_at_time</span> <span class="o">=</span> <span class="n">diffusion_function</span><span class="p">(</span>
                    <span class="n">z_nl</span><span class="p">[</span><span class="n">ind</span><span class="p">,:],</span>
                    <span class="n">interp_dx</span><span class="p">,</span>
                    <span class="n">new_dt</span><span class="p">,</span>
                    <span class="mi">1</span><span class="p">,</span> <span class="c1"># only need one time step to reach requested time</span>
                    <span class="n">k</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">diff_arg_dict</span>
                <span class="p">)</span>

                <span class="c1"># interpolate</span>
                <span class="n">interp_fun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">,</span> <span class="n">z_at_time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">interp_method</span><span class="p">)</span>
                <span class="n">z_interp</span> <span class="o">=</span> <span class="n">interp_fun</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

            <span class="c1"># compute misfit for z_interp and z_profile</span>

            <span class="c1"># compute weights</span>

            <span class="n">prof_len</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">f_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_interp</span><span class="p">))</span>
            <span class="n">f_i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">prof_len</span>
            <span class="n">f_i</span> <span class="o">*=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_i</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_i</span><span class="p">))</span>
            <span class="c1"># compute misfit</span>

            <span class="n">rmse</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_i</span><span class="o">*</span><span class="p">((</span><span class="n">z_interp</span><span class="o">-</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">rmse</span>

        <span class="c1"># set upper age boundaries if t_range = []</span>

        <span class="k">if</span> <span class="n">t_range</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">t_range</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kt</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">kt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">]</span>

        <span class="n">summaries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">best_ts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">best_z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">best_mf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t_save</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># save each timestep</span>
        <span class="n">z_save</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># save profile at each timestep</span>
        <span class="n">d_nonlin_save</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># x values for nonlinear diffusion</span>
        <span class="n">nonlin_dt</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_dt</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">):</span>

            <span class="c1"># first guess for t, just use kt</span>
            <span class="n">init_t_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating age for profile </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Upper t set to </span><span class="si">{</span><span class="n">t_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> kyr&quot;</span><span class="p">)</span>

            <span class="c1"># estimate needed profile length</span>
            <span class="n">riser_baselength</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">d_length</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">riser_baselength</span>

            <span class="c1"># check if d_length is longer than measured profile length</span>
            <span class="c1"># if not, use the profile length instead.</span>
            <span class="k">if</span> <span class="n">d_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)):</span>
                <span class="n">d_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

            <span class="n">d_nonlin</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">d_length</span><span class="p">,</span> <span class="n">d_length</span><span class="o">+</span><span class="n">interp_dx</span><span class="p">,</span> <span class="n">interp_dx</span><span class="p">)</span>
            <span class="n">z_init</span> <span class="o">=</span> <span class="n">analytical_profile</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># run the nonlinear diffusion process with the specified dt</span>

            <span class="n">z_nl</span><span class="p">,</span> <span class="n">t_nl</span> <span class="o">=</span> <span class="n">diffusion_law</span><span class="p">(</span>
                <span class="n">z_init</span><span class="p">,</span>
                <span class="n">interp_dx</span><span class="p">,</span>
                <span class="n">init_dt</span><span class="p">,</span>
                <span class="n">n_t</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">t_range</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">init_dt</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                <span class="o">**</span><span class="n">diff_arg_dict</span>
            <span class="p">)</span>

            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">diffusion_law</span><span class="p">,</span>
                <span class="n">d_nonlin</span><span class="p">,</span>
                <span class="n">z_nl</span><span class="p">,</span>
                <span class="n">t_nl</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">interp_dx</span><span class="p">,</span>
                <span class="n">k</span><span class="p">,</span>
                <span class="n">interp_method</span><span class="p">,</span>
                <span class="n">diff_arg_dict</span>
            <span class="p">)</span>

            <span class="n">fit_time</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                <span class="n">fun</span><span class="o">=</span><span class="n">nonlin_misfit_general</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">init_t_i</span><span class="p">]),</span>
                <span class="n">args</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Powell&quot;</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">t_range</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span>
            <span class="p">)</span>

            <span class="n">summaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_time</span><span class="p">)</span>
            <span class="n">best_ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_time</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">best_mf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_time</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span>
            <span class="n">d_nonlin_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">)</span>

            <span class="c1"># save the best fit profile</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t_nl</span> <span class="o">&lt;</span> <span class="n">fit_time</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">z_onestep</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">diffusion_law</span><span class="p">(</span>
                <span class="n">z_nl</span><span class="p">[</span><span class="n">ind</span><span class="p">,:],</span>
                <span class="n">interp_dx</span><span class="p">,</span>
                <span class="n">fit_time</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">t_nl</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>
                <span class="n">n_t</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                <span class="o">**</span><span class="n">diff_arg_dict</span>
            <span class="p">)</span>

            <span class="c1"># save all timesteps (including best fit)</span>
            <span class="n">t_s</span> <span class="o">=</span> <span class="n">t_nl</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">t_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_s</span><span class="p">,</span> <span class="n">fit_time</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="c1"># save all profiles (including best fit)</span>
            <span class="n">z_s</span> <span class="o">=</span> <span class="n">z_nl</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span>
            <span class="n">z_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">z_s</span><span class="p">,</span> <span class="n">z_onestep</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1">#interpolate</span>
            <span class="n">interp_fun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">d_nonlin</span><span class="p">,</span> <span class="n">z_onestep</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">interp_method</span><span class="p">)</span>
            <span class="n">best_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interp_fun</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Best fit age: </span><span class="si">{</span><span class="n">best_ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> kyr&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_opt_sum</span> <span class="o">=</span> <span class="n">summaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span> <span class="o">=</span> <span class="n">best_ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_z</span> <span class="o">=</span> <span class="n">best_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_mf</span> <span class="o">=</span> <span class="n">best_mf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_z_matrix</span> <span class="o">=</span> <span class="n">z_save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_t_times</span> <span class="o">=</span> <span class="n">t_save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_d</span> <span class="o">=</span> <span class="n">d_nonlin_save</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_dt</span> <span class="o">=</span> <span class="n">nonlin_dt</span>

        <span class="k">if</span> <span class="n">summarypdf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># pdf of best fit curve and profile for each profile</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating summary PDF ...&quot;</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">PdfPages</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_nonlinear_diffusion_summary.pdf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

                <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Measured profile&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Best fit profile&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Relative distance [m]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Relative elevation [m]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;t = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> kyr&quot;</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;darkgray&quot;</span><span class="p">)</span>

                <span class="n">fg</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.add_cn_terrace_ages"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.add_cn_terrace_ages">[docs]</a>    <span class="k">def</span> <span class="nf">add_cn_terrace_ages</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">terrace_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;terrace&quot;</span><span class="p">,</span>
        <span class="n">age_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;age&quot;</span><span class="p">,</span>
        <span class="n">sigma_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sigma&quot;</span><span class="p">,</span>
        <span class="n">pd_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assiociates the riserfit.Riser.terrace parameter of a</span>
<span class="sd">        class instance with terrace ages specified in a ``.csv``</span>
<span class="sd">        file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            filepath: str</span>
<span class="sd">                Path to subdirectory containing .csv file.</span>
<span class="sd">            terrace_col: str</span>
<span class="sd">                Column name with terrace ids/names.</span>
<span class="sd">            age_col: str</span>
<span class="sd">                Column name with terrace ages.</span>
<span class="sd">            sigma_col: str</span>
<span class="sd">                Column name with terrace age standard deviations.</span>
<span class="sd">            pd_dict: dict</span>
<span class="sd">                Any arguments passed to ``pandas.read_csv``.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">pd_dict</span><span class="p">)</span>
        <span class="n">df_terrace</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">terrace_col</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">df_ages</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">age_col</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">df_sigma</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">sigma_col</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">profile_age</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">profile_sigma</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># for each profile, find df_terrace...</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terrace</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">t_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df_terrace</span><span class="p">)</span><span class="o">==</span><span class="n">t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_id</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">profile_age</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">profile_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">profile_age</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_ages</span><span class="p">[</span><span class="n">t_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">profile_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_sigma</span><span class="p">[</span><span class="n">t_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">terrace_age</span> <span class="o">=</span> <span class="n">profile_age</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terrace_age_sigma</span> <span class="o">=</span> <span class="n">profile_sigma</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.add_parameter"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.add_parameter">[docs]</a>    <span class="k">def</span> <span class="nf">add_parameter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parameter_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">parameter_values</span><span class="p">:</span> <span class="nb">list</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic function to add a new parameter to the class instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            parameter_name: str</span>
<span class="sd">                The name of the new parameter.</span>
<span class="sd">            parameter_values: list</span>
<span class="sd">                The values (a list) of the new parameter.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_name</span><span class="p">,</span> <span class="n">parameter_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span> </div>
    
    
<div class="viewcode-block" id="Riser.add_parameter_from_file"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.add_parameter_from_file">[docs]</a>    <span class="k">def</span> <span class="nf">add_parameter_from_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">parameter_name</span><span class="p">,</span>
        <span class="n">filepath</span><span class="p">,</span>
        <span class="n">name_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">parameter_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pd_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">match_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;exact&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new parameter from a csv file to the riser instance.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            parameter_name: str</span>
<span class="sd">                Name of the new parameter to be added. available</span>
<span class="sd">                as ``self.parameter_name``.</span>
<span class="sd">            filepath: str</span>
<span class="sd">                Sub-path to CSV file.</span>
<span class="sd">            name_col: str</span>
<span class="sd">                Column name containing the names as they appear in </span>
<span class="sd">                self.name</span>
<span class="sd">            parameter_col: str</span>
<span class="sd">                The column containing the parameter values to be added.</span>
<span class="sd">                If None, assumed to be the same as parameter_name.</span>
<span class="sd">            pd_dict: dict</span>
<span class="sd">                Passed to ``pandas.read_csv``.</span>
<span class="sd">            match_type: str</span>
<span class="sd">                Determines how the names in name_column are compared to those</span>
<span class="sd">                in self.name. Default is &quot;exact&quot;, meaning that the names have</span>
<span class="sd">                to match exactly. Alternative is &quot;partial&quot;, meaning that the</span>
<span class="sd">                file names have to be contained in the riser.name names. I.e.,</span>
<span class="sd">                a file name of &quot;aaa&quot; will be matched with &quot;aaa_0&quot; (but not</span>
<span class="sd">                vice versa). If multiple occurences are found using either type</span>
<span class="sd">                of matching, the first occurence is used.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="n">filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">pd_dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">name_col</span> <span class="o">=</span> <span class="n">parameter_name</span>
        
        <span class="n">parameter_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
            <span class="c1"># find row where name entry in file is name</span>
            <span class="k">if</span> <span class="n">match_type</span> <span class="o">==</span> <span class="s2">&quot;exact&quot;</span><span class="p">:</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="o">==</span><span class="n">df_name</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">df_name</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">name_col</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="k">elif</span> <span class="n">match_type</span> <span class="o">==</span> <span class="s2">&quot;partial&quot;</span><span class="p">:</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="n">df_name</span> <span class="ow">in</span> <span class="n">name</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">df_name</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">name_col</span><span class="p">]</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;match_type not in [&#39;exact&#39;, &#39;partial&#39;]&quot;</span><span class="p">)</span>
            <span class="c1"># use first entry, if there is any True entry...</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
                <span class="n">parameter_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">id</span><span class="p">][</span><span class="n">parameter_col</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_name</span><span class="p">,</span> <span class="n">parameter_out</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>
        
<div class="viewcode-block" id="Riser.add_cn_ages"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.add_cn_ages">[docs]</a>    <span class="k">def</span> <span class="nf">add_cn_ages</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Profile&quot;</span><span class="p">,</span>
        <span class="n">age_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;avgCN&quot;</span><span class="p">,</span>
        <span class="n">sigma_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sigma&quot;</span><span class="p">,</span>
        <span class="n">reliability</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reliability_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pd_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add_cn_ages: Function to associate riser profiles with available</span>
<span class="sd">        cosmogenic nuclide (CN) ages. CN ages are loaded from a .csv</span>
<span class="sd">        file defined by the filepath and infile.</span>
<span class="sd">        This file should consist of at least:</span>
<span class="sd">        #. A column containing the profile name. If the name in the</span>
<span class="sd">        file is profileA, but profileA has been split into</span>
<span class="sd">        profileA_0, profileA_1, etc., it will still be found and the</span>
<span class="sd">        CN age associated with profileA will be assigned to</span>
<span class="sd">        profileA_0, profileA_1, etc.</span>
<span class="sd">        #. A column containing the sample (or mean sample) age.</span>
<span class="sd">        #. A column containing CN uncertainty (1sigma or similar).</span>
<span class="sd">        #. (Optional) A column indicating the reliability of CN</span>
<span class="sd">        ages.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            filepath: str</span>
<span class="sd">                Path to the folder containing a ``.csv`` file with CN ages.</span>
<span class="sd">            infile: str</span>
<span class="sd">                Name of the ``.csv`` file containing the CN ages.</span>
<span class="sd">            name_col: str</span>
<span class="sd">                Name of the column containing the profile names.</span>
<span class="sd">            age_col: str</span>
<span class="sd">                Name of the column containing the CN ages.</span>
<span class="sd">            sigma_col: str</span>
<span class="sd">                Name of the column containing the CN age uncertainties.</span>
<span class="sd">            reliability: str</span>
<span class="sd">                If some CN ages are to be treated with caution, indicate</span>
<span class="sd">                the column name storing that information here.</span>
<span class="sd">            reliability_dict: dict</span>
<span class="sd">                Dictionary containing reliability information and color</span>
<span class="sd">                for plotting, e.g.: {&quot;y&quot;: &quot;blue&quot;, &quot;n&quot;: &quot;gray&quot;}.</span>
<span class="sd">            pd_dict: dict</span>
<span class="sd">                Passed on to ``pandas.read_csv()``.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="n">filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">pd_dict</span><span class="p">)</span>

        <span class="n">cn_ages</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>
        <span class="n">cn_age_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>
        <span class="n">cn_reliability</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Searching for CN ages ...&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cn_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">name_col</span><span class="p">]):</span>

            <span class="n">riser_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">cn_name</span> <span class="ow">in</span> <span class="n">name</span><span class="p">]</span>
            <span class="c1">#print(f&quot; Ind list:{riser_index} \n CN name: {cn_name} \n Names: {self.name}&quot;)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">riser_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">riser_index</span><span class="p">:</span>
                    <span class="n">cn_ages</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">age_col</span><span class="p">]</span>
                    <span class="n">cn_age_sigma</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sigma_col</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">reliability</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">cn_reliability</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">reliability</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found age for Riser class profile </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not match </span><span class="si">{</span><span class="n">cn_name</span><span class="si">}</span><span class="s2"> from file with any Riser class profile.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cn_age</span> <span class="o">=</span> <span class="n">cn_ages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cn_age_sigma</span> <span class="o">=</span> <span class="n">cn_age_sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cn_age_reliability</span> <span class="o">=</span> <span class="n">cn_reliability</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="Riser.add_terrace_generation"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.add_terrace_generation">[docs]</a>    <span class="k">def</span> <span class="nf">add_terrace_generation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">name_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">terrace_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pd_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add terrace generations (names or numbers) to each riser profile.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            filepath: str</span>
<span class="sd">                Subdirectory and filename containing a ``.csv`` file with</span>
<span class="sd">                profile names and terrace generations.</span>
<span class="sd">            name_col: str</span>
<span class="sd">                Column name in ``.csv`` file containing profile names.</span>
<span class="sd">            terrace_col: str</span>
<span class="sd">                Column name in ``.csv`` file containing the terrace generation.</span>
<span class="sd">            verbose: str</span>
<span class="sd">                Option to print status updates.</span>
<span class="sd">            pd_dict: dict</span>
<span class="sd">                Any options passed on to ``pandas.read_csv``.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">pd_dict</span><span class="p">)</span>
        <span class="n">df_names</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">name_col</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">df_terraces</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">terrace_col</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">terrace_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dfn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df_names</span><span class="p">):</span>
            <span class="c1"># check where dfn appears in self.name</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">dfn</span> <span class="ow">in</span> <span class="n">rn</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">rn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">terrace_info</span><span class="p">[</span><span class="n">ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_terraces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found match for profile </span><span class="si">{</span><span class="n">dfn</span><span class="si">}</span><span class="s2"> from file&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">terrace</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">terrace_info</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.calculate_kt_uncertainty"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.calculate_kt_uncertainty">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_kt_uncertainty</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_upper_kt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">float_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e6</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates uncertainties in linear kt. Analogous to </span>
<span class="sd">        `Wei et al. 2015 &lt;https://doi.org/10.1016/j.jseaes.2015.02.016&gt;`_.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            tolerance: float</span>
<span class="sd">                Uncertainty bounds are determined numerically. Lowering the</span>
<span class="sd">                tolerance will increase the accuracy, but also increase</span>
<span class="sd">                computation time.</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Option to plot all diffusion ages against profile name,</span>
<span class="sd">                including uncertainty.</span>
<span class="sd">            ascending: bool</span>
<span class="sd">                Option to plot ages in ascending order.</span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Option to print results to console output.</span>
<span class="sd">            float_multiplier: float</span>
<span class="sd">                Prevents floating point errors in scipy optimize (?).</span>


<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
 
        <span class="n">l_kt</span><span class="p">,</span><span class="n">u_kt</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="c1"># briefly check if any best_kt is larger than max_upper_kt</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">)</span><span class="o">-</span><span class="n">max_upper_kt</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">delta</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;max_upper_kt smaller than np.max(self.best_kt)&quot;</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">op_kt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">):</span>

            <span class="c1"># residuals:</span>
            <span class="n">z_best</span> <span class="o">=</span> <span class="n">analytical_profile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">z_best</span>
            <span class="c1"># calculate the misfit bound:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">calculate_wei_2015_sigma</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
            <span class="n">misfit_cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_misfit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sigma</span>
            
            <span class="c1"># set up the scipy minimizer for the lower and upper</span>
            <span class="c1"># bounds, respectively</span>

            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">misfit_cutoff</span><span class="p">,</span> <span class="n">float_multiplier</span>
            <span class="p">)</span>
            
            <span class="c1"># lower bound</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lb_opt</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                    <span class="n">fun</span><span class="o">=</span><span class="n">_linear_kt_uncertainty_mse</span><span class="p">,</span>
                    <span class="n">x0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.9</span><span class="o">*</span><span class="n">op_kt</span><span class="p">]),</span>
                    <span class="n">args</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Powell&quot;</span><span class="p">,</span>
                    <span class="n">bounds</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">op_kt</span><span class="p">),)</span>
                <span class="p">)</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="n">lb_opt</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="p">(</span><span class="s2">&quot;Exception raised in linear lower bound calculation: &quot;</span>
                     <span class="o">+</span><span class="sa">f</span><span class="s2">&quot;instance: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">, profile: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                     <span class="o">+</span><span class="s2">&quot; Setting lower bound to 0.&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="c1"># upper bound</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ub_opt</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                    <span class="n">fun</span><span class="o">=</span><span class="n">_linear_kt_uncertainty_mse</span><span class="p">,</span>
                    <span class="n">x0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="o">*</span><span class="n">op_kt</span><span class="p">]),</span>
                    <span class="n">args</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Powell&quot;</span><span class="p">,</span>
                    <span class="n">bounds</span><span class="o">=</span><span class="p">((</span><span class="n">op_kt</span><span class="p">,</span> <span class="n">max_upper_kt</span><span class="p">),)</span>
                <span class="p">)</span>
                <span class="n">ub</span> <span class="o">=</span> <span class="n">ub_opt</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="p">(</span><span class="s2">&quot;Exception raised in linear upper bound calculation:&quot;</span>
                     <span class="o">+</span><span class="sa">f</span><span class="s2">&quot;instance: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">, profile: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                     <span class="o">+</span><span class="s2">&quot;Setting lower bound to 0.&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
                <span class="n">ub</span> <span class="o">=</span> <span class="n">max_upper_kt</span>
            
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;kt bounds for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Lower kt = </span><span class="si">{</span><span class="n">lb</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Upper kt = </span><span class="si">{</span><span class="n">ub</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">l_kt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
            <span class="n">u_kt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lower_kt</span> <span class="o">=</span> <span class="n">l_kt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_kt</span> <span class="o">=</span> <span class="n">u_kt</span>

        <span class="k">if</span> <span class="n">summarypdf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># plot all profile ages on y, names on x</span>
            <span class="n">y_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper_kt</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">)</span>
            <span class="n">y_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower_kt</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ascending</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">order_ID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">)</span>
                <span class="n">y_uncert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y_lower</span><span class="p">[</span><span class="n">order_ID</span><span class="p">],</span> <span class="n">y_upper</span><span class="p">[</span><span class="n">order_ID</span><span class="p">]])</span>
                <span class="n">kt_age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">)[</span><span class="n">order_ID</span><span class="p">]</span>
                <span class="n">prof_name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="n">order_ID</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_uncert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y_lower</span><span class="p">,</span> <span class="n">y_upper</span><span class="p">])</span>
                <span class="n">kt_age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">)</span>
                <span class="n">prof_name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="n">plot_at</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">))]</span>
            <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">plot_at</span><span class="p">,</span> <span class="n">kt_age</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">y_uncert</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">ecolor</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">elinewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">capthick</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">plot_at</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">prof_name</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">labelrotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$kt$ [m$^2$]&quot;</span><span class="p">)</span>
            <span class="n">fg</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_summary_kt_uncertainty.pdf&quot;</span><span class="p">,</span>
                <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.calculate_nonlin_t_uncertainty"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.calculate_nonlin_t_uncertainty">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_nonlin_t_uncertainty</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">S_c</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> 
        <span class="n">warning_eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">10e-15</span><span class="p">,</span>
        <span class="n">max_upper_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">float_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e6</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate uncertainty bounds for</span>
<span class="sd">        nonlinear age. Analogous to </span>
<span class="sd">        `Wei et al. 2015 &lt;https://doi.org/10.1016/j.jseaes.2015.02.016&gt;`_.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            k: float</span>
<span class="sd">                Nonlinear diffusion coefficient</span>
<span class="sd">            S_c: float</span>
<span class="sd">                Critical slope.</span>
<span class="sd">            n: int</span>
<span class="sd">                Exponent in the nonlinear diffusion equation.</span>
<span class="sd">            dt: float</span>
<span class="sd">                Time step for diffusion model.</span>
<span class="sd">            warning_eps: float</span>
<span class="sd">                Raise warning if slopes of the modelled profiles</span>
<span class="sd">                are smaller than warning_eps.</span>
<span class="sd">            max_upper_t: float</span>
<span class="sd">                If None, upper bound is set to ``self.nonlin_best_t[i]+5000``.</span>
<span class="sd">                Otherwise, upper bound is equal to ``max_upper_t``.</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Option to plot all diffusion ages against profile name,</span>
<span class="sd">                including uncertainty.</span>
<span class="sd">            ascending: bool</span>
<span class="sd">                Option to plot ages in ascending order.</span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Option to print results to console output.</span>
<span class="sd">            float_multiplier: float</span>
<span class="sd">                Prevents floating point errors in scipy optimize (?).</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># calculate upper_t_bounds</span>
        <span class="k">if</span> <span class="n">max_upper_t</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upper_t_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">))</span><span class="o">*</span><span class="n">upper_t_bound</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upper_t_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">)</span><span class="o">+</span><span class="mi">5000</span>

        <span class="n">l_t</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># saving upper and lower t boundaries</span>
        <span class="n">u_t</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">opt_t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">):</span>
            
            <span class="c1"># MSE cutoff criterion</span>
            <span class="n">residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">calculate_wei_2015_sigma</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
            <span class="n">misfit_cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_mf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sigma</span>

            <span class="c1"># spacing</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># get existing nonlin_z_matrix and nonlin_t_times</span>
            <span class="c1"># if empty, compute again</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_z_matrix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                
                <span class="n">z_init</span> <span class="o">=</span> <span class="n">analytical_profile</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
                
                <span class="n">n_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">upper_t_bound</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">dt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                <span class="n">z_nl_uncert</span><span class="p">,</span> <span class="n">t_nl_uncert</span> <span class="o">=</span> <span class="n">nonlin_diff_perron2011</span><span class="p">(</span>
                    <span class="n">z_init</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">n_t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">S_c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">warning_eps</span>
                <span class="p">)</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># use the already existing nonlin_z_matrix</span>
                <span class="c1"># to reduce computation time...</span>
                <span class="n">z_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_z_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="c1"># z at opt_t</span>
                <span class="n">t_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_t_times</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">n_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">upper_t_bound</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">t_max</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">nl_z_matrix2</span><span class="p">,</span> <span class="n">nl_t_matrix2</span> <span class="o">=</span> <span class="n">nonlin_diff_perron2011</span><span class="p">(</span>
                    <span class="n">z_init</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">n_t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">S_c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">warning_eps</span>
                <span class="p">)</span>
                <span class="n">nl_t_matrix2</span> <span class="o">+=</span> <span class="n">opt_t</span> <span class="c1"># first entry is zero by default...</span>
                <span class="c1"># concatenate with existing matrix:</span>
                <span class="c1"># (last time step is there twice, remove once)</span>
                <span class="n">z_nl_uncert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_z_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:],</span> <span class="n">nl_z_matrix2</span><span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">t_nl_uncert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_t_times</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nl_t_matrix2</span><span class="p">)</span>
                <span class="p">)</span>
    
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">S_c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">warning_eps</span><span class="p">,</span> <span class="n">z_nl_uncert</span><span class="p">,</span> <span class="n">t_nl_uncert</span><span class="p">,</span> <span class="n">misfit_cutoff</span><span class="p">,</span>
                <span class="n">float_multiplier</span>
            <span class="p">)</span>
            <span class="c1"># optimize for lower_t:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lower_t_opt</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                    <span class="n">fun</span><span class="o">=</span><span class="n">_nonlinear_t_uncertainty_mse</span><span class="p">,</span>
                    <span class="n">x0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">opt_t</span><span class="o">*</span><span class="mf">0.9</span><span class="p">]),</span>
                    <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Powell&quot;</span><span class="p">,</span>
                    <span class="n">bounds</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">opt_t</span><span class="p">),)</span>
                <span class="p">)</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="n">lower_t_opt</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&#39;&#39;&#39;TODO: What causes ValueError???&#39;&#39;&#39;</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="p">(</span><span class="s2">&quot;Exception raised in nonlinear lower bound calculation:&quot;</span>
                     <span class="o">+</span><span class="sa">f</span><span class="s2">&quot;instance: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">, profile: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                     <span class="o">+</span><span class="s2">&quot;Setting lower bound to 0.&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
                <span class="n">lb</span><span class="o">=</span><span class="mi">0</span>

            <span class="c1"># optimize for upper_t:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">upper_t_opt</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                    <span class="n">fun</span><span class="o">=</span><span class="n">_nonlinear_t_uncertainty_mse</span><span class="p">,</span>
                    <span class="n">x0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">opt_t</span><span class="o">*</span><span class="mf">1.1</span><span class="p">]),</span>
                    <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Powell&quot;</span><span class="p">,</span>
                    <span class="n">bounds</span><span class="o">=</span><span class="p">((</span><span class="n">opt_t</span><span class="p">,</span> <span class="n">upper_t_bound</span><span class="p">[</span><span class="n">i</span><span class="p">]),)</span>
                <span class="p">)</span>
                <span class="n">ub</span> <span class="o">=</span> <span class="n">upper_t_opt</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="p">(</span><span class="s2">&quot;Exception raised in nonlinear upper bound calculation:&quot;</span>
                     <span class="o">+</span><span class="sa">f</span><span class="s2">&quot;instance: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">, profile: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
                     <span class="o">+</span><span class="sa">f</span><span class="s2">&quot;Setting upper bound to </span><span class="si">{</span><span class="n">upper_t_bound</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
                <span class="n">ub</span><span class="o">=</span><span class="n">upper_t_bound</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        
            <span class="n">l_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
            <span class="n">u_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating t bounds for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Lower t = </span><span class="si">{</span><span class="n">lb</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> kyr&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Best t = </span><span class="si">{</span><span class="n">opt_t</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> kyr&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Upper t = </span><span class="si">{</span><span class="n">ub</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> kyr&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_lower_t</span> <span class="o">=</span> <span class="n">l_t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_upper_t</span> <span class="o">=</span> <span class="n">u_t</span>

        <span class="k">if</span> <span class="n">summarypdf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># plot all profile ages on y, names on x</span>
            <span class="n">y_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_upper_t</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">)</span>
            <span class="n">y_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_lower_t</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ascending</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">order_ID</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">)</span>
                <span class="n">y_uncert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y_lower</span><span class="p">[</span><span class="n">order_ID</span><span class="p">],</span> <span class="n">y_upper</span><span class="p">[</span><span class="n">order_ID</span><span class="p">]])</span>
                <span class="n">kt_age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">)[</span><span class="n">order_ID</span><span class="p">]</span>
                <span class="n">prof_name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="n">order_ID</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_uncert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y_lower</span><span class="p">,</span> <span class="n">y_upper</span><span class="p">])</span>
                <span class="n">kt_age</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">)</span>
                <span class="n">prof_name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="n">plot_at</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">))]</span>
            <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">plot_at</span><span class="p">,</span> <span class="n">kt_age</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">y_uncert</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">ecolor</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">elinewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">capthick</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">plot_at</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">prof_name</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">labelrotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;t [kyr]&quot;</span><span class="p">)</span>
            <span class="n">fg</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_summary_nonlin_uncertainty.pdf&quot;</span><span class="p">,</span>
                <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.jackknife_linear_diffusion_fit"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.jackknife_linear_diffusion_fit">[docs]</a>    <span class="k">def</span> <span class="nf">jackknife_linear_diffusion_fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">fraction_reduction</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">every_kth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">warning_eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e-10</span><span class="p">,</span>
        <span class="n">lin_diff_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a range of kt and other parameters for linear diffusion</span>
<span class="sd">        based on a profile consisting only of a subset of points from</span>
<span class="sd">        the original profile.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            iterations: int</span>
<span class="sd">                The number of resamples undertaken for each profile.</span>
<span class="sd">            fraction_reduction: float</span>
<span class="sd">                Fraction of points to be left out of the subset.</span>
<span class="sd">            every_kth: int</span>
<span class="sd">                If larger than 0, used for sampling points. </span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Option to print progress statements to console.</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Print a PDF showing jackknifing histograms.</span>
<span class="sd">            lin_diff_dict: dict</span>
<span class="sd">                Additional arguments passed to </span>
<span class="sd">                ``Riser.compute_best_linear_diffusion_fit()``.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

        <span class="c1"># save original d, z</span>
        <span class="c1"># save original linear diffusion fit results</span>
        <span class="n">save_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_a</span><span class="p">,</span> <span class="n">save_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_doff</span><span class="p">,</span> <span class="n">save_zoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_z_off</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_kt</span><span class="p">,</span> <span class="n">save_sum</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_summary</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_mf</span><span class="p">,</span> <span class="n">save_midgrad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_misfit</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_midpoint_grad</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># save results of each iteration here</span>
        <span class="c1"># this is terrible but there were some problems with</span>
        <span class="c1"># identical arrays in different variables...</span>
        <span class="c1">#prof_z = [[] for _ in range(0, len(self.name))]</span>
        <span class="c1">#prof_d = [[] for _ in range(0, len(self.name))]</span>
        <span class="n">prof_a</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>
        <span class="n">prof_b</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>
        <span class="n">prof_doff</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>
        <span class="n">prof_zoff</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>
        <span class="n">prof_kt</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>
        <span class="n">prof_sum</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>
        <span class="n">prof_mf</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>
        <span class="n">prof_midgrad</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Linear jackknife algorithm:&quot;</span><span class="p">)</span>

        <span class="c1"># only need one iteration to check every_kth</span>
        <span class="k">if</span> <span class="n">every_kth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iterations</span><span class="p">):</span>

            <span class="c1">#if verbose: sys.stdout.write(&#39;\033[2K\033[1G&#39;)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;Starting iteration </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">iterations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># subsample each profile</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

                <span class="n">sample_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">save_d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">fraction_reduction</span><span class="p">))</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">save_d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
                
                <span class="k">if</span> <span class="n">every_kth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">id_sample</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[::</span><span class="n">every_kth</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">id_sample</span> <span class="o">=</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">sample_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">id_sample</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_z</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">id_sample</span><span class="p">]</span>
                <span class="c1">#prof_z[j].append(self.z[j])</span>
                <span class="c1">#prof_d[j].append(self.d[j])</span>

            <span class="c1"># are all of the indices just the same?</span>

            <span class="c1"># compute linear diffusion fit for all profiles</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">compute_best_linear_diffusion_fit</span><span class="p">(</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">warning_eps</span> <span class="o">=</span> <span class="n">warning_eps</span><span class="p">,</span>
                <span class="o">**</span><span class="n">lin_diff_dict</span>
            <span class="p">)</span>

            <span class="c1"># append results...</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="n">prof_kt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">prof_a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">prof_b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">prof_doff</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">prof_zoff</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_z_off</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">prof_sum</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimize_summary</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">prof_mf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_misfit</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">prof_midgrad</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_midpoint_grad</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;... Done&quot;</span><span class="p">)</span>
        <span class="c1"># save to self.jack_ ...</span>

        <span class="c1">#self.jack_d = prof_d</span>
        <span class="c1">#self.jack_z = prof_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_kt</span> <span class="o">=</span> <span class="n">prof_kt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_a</span> <span class="o">=</span> <span class="n">prof_a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_b</span> <span class="o">=</span> <span class="n">prof_b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_d_off</span> <span class="o">=</span> <span class="n">prof_doff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_z_off</span> <span class="o">=</span> <span class="n">prof_zoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_optimize_summary</span> <span class="o">=</span> <span class="n">prof_sum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_misfit</span> <span class="o">=</span> <span class="n">prof_mf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jack_midpoint_gradient</span> <span class="o">=</span> <span class="n">prof_midgrad</span>

        <span class="c1"># replace original d, z etc.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">save_d</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">save_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span> <span class="o">=</span> <span class="n">save_a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span> <span class="o">=</span> <span class="n">save_b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span> <span class="o">=</span> <span class="n">save_kt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_misfit</span> <span class="o">=</span> <span class="n">save_mf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimize_summary</span> <span class="o">=</span> <span class="n">save_sum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_d_off</span> <span class="o">=</span> <span class="n">save_doff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_z_off</span> <span class="o">=</span> <span class="n">save_zoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_midpoint_grad</span> <span class="o">=</span> <span class="n">save_midgrad</span>

        <span class="k">if</span> <span class="n">summarypdf</span><span class="p">:</span>
            <span class="c1">#cGray = [0.2, 0.2, 0.2]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving summary PDF to </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> 
                    <span class="n">end</span><span class="o">=</span><span class="s2">&quot;... &quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">PdfPages</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_linear_jackknife.pdf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

                <span class="c1"># create text:</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;std = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jack_kt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="c1">#t2 = f&quot;upper kt = {self.upper_kt[i]:.2f}\n&quot;</span>
                <span class="c1">#t3 = f&quot;lower kt = {self.lower_kt[i]:.2f}&quot;</span>
                <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jack_kt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightgray&quot;</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jack_kt</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                        <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;kt [m$^2$]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Density&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
                <span class="c1">#ax.text</span>
                <span class="n">fg</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.jackknife_nonlinear_diffusion_fit"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.jackknife_nonlinear_diffusion_fit">[docs]</a>    <span class="k">def</span> <span class="nf">jackknife_nonlinear_diffusion_fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">fraction_reduction</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">summarypdf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">nonlin_diff_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a range of kt and other parameters for nonlinear diffusion</span>
<span class="sd">        based on a profile consisting only of a subset of points from</span>
<span class="sd">        the original profile.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            iterations: int</span>
<span class="sd">                The number of resamples undertaken for each profile.</span>
<span class="sd">            fraction_reduction: float</span>
<span class="sd">                Fraction of points to be removed  from the set of points.</span>
<span class="sd">            verbose: bool</span>
<span class="sd">                Option to print progress statements to console.</span>
<span class="sd">            summarypdf: bool</span>
<span class="sd">                Print a PDF showing jackknifing histograms.</span>
<span class="sd">            nonlin_diff_dict: dict</span>
<span class="sd">                Additional arguments passed to </span>
<span class="sd">                ``Riser.compute_best_nonlinear_diffusion_fit()``.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

        <span class="c1"># save original d, z</span>
        <span class="c1"># save original linear diffusion fit results</span>
        <span class="n">save_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># save results of compute_best_nonlinear_diffusion_fit()</span>
        <span class="n">save_nbt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_nos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_opt_sum</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_nbz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_nzm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_z_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_ntt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_t_times</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_nbm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_mf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">save_nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_dt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># save results of each iteration here</span>
        <span class="c1"># this is terrible but there were some problems with</span>
        <span class="c1"># identical arrays in different variables...</span>
        <span class="n">prof_nonlin_best_t</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nonlinear jackknife algorithm:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iterations</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;Starting iteration </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">iterations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># subsample each profile</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

                <span class="n">sample_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">fraction_reduction</span><span class="p">))</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]))))</span>
                <span class="n">id_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">sample_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">id_sample</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">save_z</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">id_sample</span><span class="p">]</span>

            <span class="c1"># compute nonlinear diffusion fit for all profiles</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">compute_best_nonlinear_diffusion_fit</span><span class="p">(</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">nonlin_diff_dict</span>
            <span class="p">)</span>

            <span class="c1"># append results...</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="n">prof_nonlin_best_t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

        <span class="c1"># save to self.jack_ ...</span>

        <span class="c1">#self.jack_d = prof_d</span>
        <span class="c1">#self.jack_z = prof_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_jack_best_t</span> <span class="o">=</span> <span class="n">prof_nonlin_best_t</span>

        <span class="c1"># replace original d, z etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">save_d</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">save_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span> <span class="o">=</span> <span class="n">save_nbt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_opt_sum</span> <span class="o">=</span> <span class="n">save_nos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_z</span> <span class="o">=</span> <span class="n">save_nbz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_z_matrix</span> <span class="o">=</span> <span class="n">save_nzm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_t_times</span> <span class="o">=</span> <span class="n">save_ntt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_d</span> <span class="o">=</span> <span class="n">save_nd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_mf</span> <span class="o">=</span> <span class="n">save_nbm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_dt</span> <span class="o">=</span> <span class="n">save_nd</span>

        <span class="k">if</span> <span class="n">summarypdf</span><span class="p">:</span>
            <span class="c1">#cGray = [0.2, 0.2, 0.2]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating summary PDF&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;... &quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">PdfPages</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">_nonlinear_jackknife.pdf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

                <span class="c1"># create text:</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;std = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_jack_best_t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonlin_upper_t</span> <span class="o">!=</span> <span class="p">[]:</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;upper kt = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_upper_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">t3</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;lower kt = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_lower_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">t3</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_jack_best_t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightgray&quot;</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_jack_best_t</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                    <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                        <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;kt$_</span><span class="si">{nl}</span><span class="s2">$ [m$^2$]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Density&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">t1</span><span class="o">+</span><span class="n">t2</span><span class="o">+</span><span class="n">t3</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>
                <span class="c1">#ax.text</span>
                <span class="n">fg</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pdf&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.calculate_parameter_uncertainties"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.calculate_parameter_uncertainties">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_parameter_uncertainties</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.4901161193847656e-08</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates confidence bands by treating the parameter estimation</span>
<span class="sd">        as a nonlinear regression problem </span>
<span class="sd">        (`see here &lt;https://www.youtube.com/watch?v=3IgIToOV2Wk&gt;`_).</span>
<span class="sd">        Results are stored in self.parameter_uncertainties.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            epsilon: Union[ArrayLike, float]</span>
<span class="sd">                The epsilon (delta value) used for calculating</span>
<span class="sd">                derivatives numerically.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">uncerts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>

            <span class="n">x_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">param_vals</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;kt&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                <span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">}</span>

            <span class="n">jacobian</span> <span class="o">=</span> <span class="n">calculate_function_jacobian</span><span class="p">(</span>
                <span class="n">analytical_profile</span><span class="p">,</span>
                <span class="n">x_values</span><span class="o">=</span><span class="n">x_vals</span><span class="p">,</span>
                <span class="n">parameter_values</span><span class="o">=</span><span class="n">param_vals</span><span class="p">,</span>
                <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span>
            <span class="p">)</span>

            <span class="n">z_best</span> <span class="o">=</span> <span class="n">analytical_profile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_b</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># weights</span>
            <span class="n">prof_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">f_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">f_i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">prof_len</span>
            <span class="n">f_i</span> <span class="o">*=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_i</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_i</span><span class="p">))</span>

            <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">z_best</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="n">cov_matrix</span> <span class="o">=</span> <span class="n">riser_covariance_matrix</span><span class="p">(</span>
                <span class="n">jacobian</span><span class="o">=</span><span class="n">jacobian</span><span class="p">,</span>
                <span class="n">sum_of_squares</span><span class="o">=</span><span class="n">sos</span>
            <span class="p">)</span>

            <span class="n">uncerts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cov_matrix</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameter_uncertainties</span> <span class="o">=</span> <span class="n">uncerts</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>
    
<div class="viewcode-block" id="Riser.construct_StatsMC_instance"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.construct_StatsMC_instance">[docs]</a>    <span class="k">def</span> <span class="nf">construct_StatsMC_instance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kt_parameter_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;best_kt&quot;</span><span class="p">,</span>
        <span class="n">kt_lb_parameter_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lower_kt&quot;</span><span class="p">,</span>
        <span class="n">kt_ub_parameter_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;upper_kt&quot;</span><span class="p">,</span>
        <span class="n">t_parameter_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cn_age&quot;</span><span class="p">,</span>
        <span class="n">t_sigma_parameter_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cn_age_sigma&quot;</span><span class="p">,</span>
        <span class="n">identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function return a tuple of ``StatsMC`` instances. How many instances</span>
<span class="sd">        are created depends on the number of different entries in the</span>
<span class="sd">        ``t_parameter_name`` list. I.e., if all risers have the same age,</span>
<span class="sd">        only one instance is returned.</span>
<span class="sd">        If any risers have the entry np.nan associated, they are grouped into</span>
<span class="sd">        their own ``StatsMC`` entry and take up the last position in the returned</span>
<span class="sd">        tuple.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            kt_parameter_name: str</span>
<span class="sd">                Determines whether to use linear or nonlinear diffusion, so</span>
<span class="sd">                should be either &quot;best_kt&quot; (for linear diffusion) or </span>
<span class="sd">                &quot;nonlin_best_t&quot; (for nonlinear diffusion). Default is linear</span>
<span class="sd">                diffusion.</span>
<span class="sd">            kt_lb_parameter_name: str</span>
<span class="sd">                Determines if bounds from linear or nonlinear diffusion are </span>
<span class="sd">                to be used. Default is &quot;lower_kt&quot; (linear diffusion)l</span>
<span class="sd">                alternative is &quot;nonlin_lower_t&quot; (nonlinear diffusion).</span>
<span class="sd">            kt_ub_parameter_name: str</span>
<span class="sd">                Determines if bounds from linear or nonlinear diffusion are </span>
<span class="sd">                to be used. Default is &quot;upper_kt&quot; (linear diffusion)</span>
<span class="sd">                alternative is &quot;nonlin_upper_t&quot; (nonlinear diffusion).</span>
<span class="sd">            t_parameter_name: str</span>
<span class="sd">                Parameter storing age information. This can also be an array</span>
<span class="sd">                of length ``n`` for each riser, indicating that there are multiple</span>
<span class="sd">                available ages to be used. If so, the t PDF used for MC </span>
<span class="sd">                simulations will be a composite Gaussian distribution. Default</span>
<span class="sd">                is &quot;cn_age&quot;.</span>
<span class="sd">                The data stored in ``getattr(self, t_parameter_name)[i]`` needs to</span>
<span class="sd">                be either a numerical value (float, ...) or a ``np.array``. Lists</span>
<span class="sd">                are not supported.</span>
<span class="sd">            t_sigma_parameter_name: str</span>
<span class="sd">                Parameter storing the uncertainty information associated with</span>
<span class="sd">                each entry in ``t_parameter_name``. These entries must have the same</span>
<span class="sd">                format as those in ``t_parameter_name``. I.e., if the latter is </span>
<span class="sd">                an array of length n for a single riser, the corresponding </span>
<span class="sd">                information in ``t_sigma_parameter_name`` also needs to be an </span>
<span class="sd">                array of length ``n``.</span>
<span class="sd">            identifier: str</span>
<span class="sd">                Set the ``StatsMC.identifier`` property of the created instance.</span>
<span class="sd">                If ``None``, ``Riser.indentifier`` is used.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            statsMC: Tuple</span>
<span class="sd">                A length ``n`` tuple containing instances of ``riserfit.StatsMC``.</span>
<span class="sd">                If some risers do not have an age assigned, they are grouped</span>
<span class="sd">                in the last returned ``StatsMC`` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">def</span> <span class="nf">_selector</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">par</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">]</span>
        
        <span class="n">ts</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_parameter_name</span><span class="p">)</span>
        <span class="n">ts_sigma</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_sigma_parameter_name</span><span class="p">)</span>
        
        <span class="n">kts</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kt_parameter_name</span><span class="p">)</span>
        <span class="n">kts_lb</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kt_lb_parameter_name</span><span class="p">)</span>
        <span class="n">kts_ub</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kt_ub_parameter_name</span><span class="p">)</span>
        
        <span class="c1"># find unique entries in ts:</span>
        <span class="n">unique_t</span> <span class="o">=</span> <span class="p">[</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_t</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">u_t</span> <span class="ow">in</span> <span class="n">unique_t</span><span class="p">]):</span>
                <span class="n">unique_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="n">instance_list</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">u_t</span> <span class="ow">in</span> <span class="n">unique_t</span><span class="p">:</span>
            
            <span class="c1"># nan ages are grouped into their own instance.</span>
            <span class="c1"># use list comprehension to avoid accidental concats by numpy...</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">u_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">kts_id</span> <span class="o">=</span> <span class="n">_selector</span><span class="p">(</span><span class="n">kts</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span>
            <span class="n">lb_id</span> <span class="o">=</span> <span class="n">_selector</span><span class="p">(</span><span class="n">kts_lb</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span>
            <span class="n">ub_id</span> <span class="o">=</span> <span class="n">_selector</span><span class="p">(</span><span class="n">kts_ub</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span>
            <span class="n">t_id</span> <span class="o">=</span> <span class="n">_selector</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">ids</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ts_id</span> <span class="o">=</span> <span class="n">_selector</span><span class="p">(</span><span class="n">ts_sigma</span><span class="p">,</span> <span class="n">ids</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">identifier</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">set_id</span> <span class="o">=</span> <span class="n">identifier</span> 
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">set_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span>
                
            <span class="n">instance_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">StatsMC</span><span class="p">(</span>
                    <span class="n">kt</span><span class="o">=</span><span class="n">kts_id</span><span class="p">,</span>
                    <span class="n">lb_kt</span><span class="o">=</span><span class="n">lb_id</span><span class="p">,</span>
                    <span class="n">ub_kt</span><span class="o">=</span><span class="n">ub_id</span><span class="p">,</span>
                    <span class="n">t</span><span class="o">=</span><span class="n">t_id</span><span class="p">,</span>
                    <span class="n">t_sigma</span><span class="o">=</span><span class="n">ts_id</span><span class="p">,</span>
                    <span class="n">identifier</span><span class="o">=</span><span class="n">set_id</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">instance_list</span><span class="p">)</span></div>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Some functions that are useful for contextual analysis and plotting</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="Riser.extract_profile_elevation"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.extract_profile_elevation">[docs]</a>    <span class="k">def</span> <span class="nf">extract_profile_elevation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rasterpath</span><span class="p">,</span>
        <span class="n">band_no</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">surface</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">rio_open_params</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract profile elevations using a DEM or REM. Depending on the value</span>
<span class="sd">        of surface, the first or last point of each profile is used to calculate</span>
<span class="sd">        the profile elevation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            rasterpath: str</span>
<span class="sd">                Path to file containing a raster with river-relative elevations</span>
<span class="sd">            band_no: int</span>
<span class="sd">                Band containing elevation.</span>
<span class="sd">            surface: str</span>
<span class="sd">                Extract elevation from the &#39;upper&#39; or &#39;lower&#39; terrace surface.</span>
<span class="sd">            method: str</span>
<span class="sd">                Interpolation method used to extract relative elevations. Can</span>
<span class="sd">                take any value allowed by ``scipy.interpolate.interpn()``.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The riser instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># construct points list:</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="c1"># approximate using first point in each profile</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">yy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">yy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">surface</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="c1"># approximate using last point in each profile (upper surface)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">yy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">yy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;surface must be either &#39;lower&#39; or &#39;upper&#39;&quot;</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
        <span class="n">elevations</span> <span class="o">=</span> <span class="n">sample_raster_at_points</span><span class="p">(</span>
            <span class="n">rasterpath</span><span class="p">,</span>
            <span class="n">points</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">band_no</span><span class="p">,</span>
            <span class="o">**</span><span class="n">rio_open_params</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">profile_elevation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elevations</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Riser.calculate_upstream_distance"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.calculate_upstream_distance">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_upstream_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">riverpath</span><span class="p">,</span>
        <span class="n">surface</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span>
        <span class="n">df_x</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span>
        <span class="n">df_y</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span>
        <span class="n">df_dist</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;distance&quot;</span><span class="p">,</span>
        <span class="n">invert_distances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a ``.csv`` file containing points describing a river path and calculates</span>
<span class="sd">        the along-stream distance for each Riser profile (based on the first or last</span>
<span class="sd">        point of each profile).</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            riverpath: str</span>
<span class="sd">                Path to ``.csv`` file containing ``(x, y)`` points describing the</span>
<span class="sd">                river path.</span>
<span class="sd">            df_x: str</span>
<span class="sd">                Name of the ``.csv`` column containing the ``x`` coordinate.</span>
<span class="sd">            df_y: str</span>
<span class="sd">                Name of the ``.csv`` column containing the ``y`` coordinate.</span>
<span class="sd">            df_dist: str</span>
<span class="sd">                Name of the column containing the distances between points along,</span>
<span class="sd">                the river line, if already calculated. Set to ``&quot;&quot;`` if </span>
<span class="sd">                not present in ``.csv`` file.</span>
<span class="sd">            invert_distances: bool</span>
<span class="sd">                Option to flip the points. Will calculate distances in the</span>
<span class="sd">                opposite way.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The Riser instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># read river .csv file</span>
        <span class="n">river_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">riverpath</span><span class="p">)</span>

        <span class="c1"># get x, y coordinates:</span>
        <span class="n">river_x</span> <span class="o">=</span> <span class="n">river_df</span><span class="p">[</span><span class="n">df_x</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">river_y</span> <span class="o">=</span> <span class="n">river_df</span><span class="p">[</span><span class="n">df_y</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># change order if wanted.</span>
        <span class="k">if</span> <span class="n">invert_distances</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">river_x</span> <span class="o">=</span> <span class="n">river_x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">river_y</span> <span class="o">=</span> <span class="n">river_y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># if df_dist == &quot;&quot;, calculate along-stream distances for each node</span>
        <span class="n">river_diff_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">river_x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df_dist</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">river_diff_dists</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">river_x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">river_x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">river_y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">river_y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">river_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">river_diff_dists</span><span class="p">)</span>
            <span class="n">df_dist</span> <span class="o">=</span> <span class="s2">&quot;distance&quot;</span>
            <span class="n">river_df</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">river_dists</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">river_dists</span> <span class="o">=</span> <span class="n">river_df</span><span class="p">[</span><span class="n">df_dist</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="c1"># only change order if values are taken from DataFrame,</span>
            <span class="c1"># else calculated from already rearranged coordinate points.</span>
            <span class="k">if</span> <span class="n">invert_distances</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">river_dists_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">river_dists</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">river_dists_new</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> \
                    <span class="n">river_dists</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">river_dists</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">river_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">river_dists_new</span><span class="p">)</span>

        <span class="c1"># get point coordinates for all points in Riser instance</span>
        <span class="k">if</span> <span class="n">surface</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="c1"># approximate using first point in each profile</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">yy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">yy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">surface</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="c1"># approximate using last point in each profile (upper surface)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">yy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">yy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;surface must be either &#39;lower&#39; or &#39;upper&#39;&quot;</span><span class="p">)</span>
        <span class="n">xy_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>

        <span class="n">point_upstream_dist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xy_points</span><span class="p">):</span>
            <span class="c1"># calulcate distance between x, y and each river point:</span>
            <span class="n">point_river_dists</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">river_x</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">river_y</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">min_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">point_river_dists</span><span class="p">)</span>
            <span class="c1">#plt.plot(point_river_dists)</span>
            <span class="c1">#plt.show()</span>
            <span class="n">point_upstream_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">river_dists</span><span class="p">[</span><span class="n">min_id</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">upstream_distance</span> <span class="o">=</span> <span class="n">point_upstream_dist</span>
        
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Riser.resample_raster_along_profiles"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.resample_raster_along_profiles">[docs]</a>    <span class="k">def</span> <span class="nf">resample_raster_along_profiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rasterpath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">band_no</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">autocenter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">savedir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample elevation values of all profiles in Riser instance using data</span>
<span class="sd">        from a DEM in rasterpath.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            rasterpath: str</span>
<span class="sd">                Path to subdirectory containing the DEM in a format accepted</span>
<span class="sd">                by ``rasterio.open()``.</span>
<span class="sd">            band_no: int</span>
<span class="sd">                Raster band to be interpreted as the DEM.</span>
<span class="sd">            method: str</span>
<span class="sd">                Interpolation method used to extract elevation values from the</span>
<span class="sd">                DEM.</span>
<span class="sd">            autocenter: bool</span>
<span class="sd">                Option to center the new elevations at ``z=0``. True by default.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                The riser instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">savedir</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="c1"># check if savedir exists and load x, y, d, z info from  there.</span>
            <span class="n">savedir_exists</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="n">savedir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">savedir</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">savedir_exists</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">loadpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="n">savedir</span><span class="si">}</span><span class="se">\\</span><span class="s2">&quot;</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">loadpath</span><span class="p">)</span>
            <span class="n">csv_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>
            <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">loadpath</span><span class="o">+</span><span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>
            <span class="n">self_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">csv_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">csv_names</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading elevation values for profile </span><span class="si">{</span><span class="n">csv_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># find out which self.name corresponds to csv_name</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">self_names</span><span class="o">==</span><span class="n">csv_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">z_dem</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_dem</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resampling elevations of profile </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># get x, y coordinates in rc format:</span>
                <span class="n">rc_points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
                <span class="c1"># sample raster</span>
                <span class="n">z_dem</span> <span class="o">=</span> <span class="n">sample_raster_at_points</span><span class="p">(</span>
                    <span class="n">rasterpath</span><span class="p">,</span>
                    <span class="n">rc_points</span><span class="p">,</span>
                    <span class="n">method</span><span class="p">,</span>
                    <span class="n">band_no</span>
                <span class="p">)</span>
                <span class="c1"># center the new elevations</span>
                <span class="k">if</span> <span class="n">autocenter</span><span class="p">:</span>
                    <span class="n">z_mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_dem</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="n">z_dem</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="c1">#print(z_mid)</span>
                    <span class="n">id_mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z_dem</span><span class="o">&lt;</span><span class="n">z_mid</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">z_mid</span> <span class="o">=</span> <span class="n">z_dem</span><span class="p">[</span><span class="n">id_mid</span><span class="p">]</span>
                    <span class="n">z_dem</span> <span class="o">=</span> <span class="n">z_dem</span> <span class="o">-</span> <span class="n">z_mid</span>
                <span class="n">z_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_dem</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z_out</span>

        <span class="k">if</span> <span class="n">savedir</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">savedir_exists</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="n">savedir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">savedir</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="c1"># save x, y, d, z in .csv file for faster reloading next time.</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                    <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">})</span>
                <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="n">savedir</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_DEM.csv&quot;</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="bp">self</span></div>
    
    
<div class="viewcode-block" id="Riser.merge_Riser_instances"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.merge_Riser_instances">[docs]</a>    <span class="k">def</span> <span class="nf">merge_Riser_instances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">riser_instance_list</span><span class="p">:</span> <span class="nb">list</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the information stored in other Riser instances in the Riser instance</span>
<span class="sd">        that calls this function. Only affects information stored in list type.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            riser_instance_list: list</span>
<span class="sd">                List of other Riser instances to be merged into self.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            self: Self</span>
<span class="sd">                A Riser instance containing the merged instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">riser_instance_list</span><span class="p">:</span>
            
            <span class="c1"># get all attributes of list type</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                <span class="c1"># get base riser attribute</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">attr_base</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                    <span class="c1"># get to be added attr</span>
                    <span class="n">attr_r</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                    <span class="n">attr_out</span> <span class="o">=</span> <span class="n">attr_base</span> <span class="o">+</span> <span class="n">attr_r</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">attr_out</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="bp">self</span></div>
        
<div class="viewcode-block" id="Riser.save_Riser_instance_structure"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.save_Riser_instance_structure">[docs]</a>    <span class="k">def</span> <span class="nf">save_Riser_instance_structure</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">savedir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a .npy file containing all attributes of the Riser class</span>
<span class="sd">        instance. This file can be used via </span>
<span class="sd">        riserfit.load_Riser_instance_structure to re-load a Riser</span>
<span class="sd">        class instance without re-running all analysis steps.</span>
<span class="sd">        File name will always be </span>
<span class="sd">        self.identifier+&quot;Riser_instance_structure.npy&quot;.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            savedir: str</span>
<span class="sd">                Subdirectory to which the resulting file is saved.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            None</span>
<span class="sd">                </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get all attributes that are not methods, or __NAME__</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> 
              <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> 
              <span class="ow">and</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attr</span><span class="p">))]</span>

        <span class="c1"># use a numpy data array with object dtype</span>
        <span class="n">riser_npy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">riser_npy</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span>
            <span class="n">riser_npy</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="n">save_str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> 
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="si">{</span><span class="n">savedir</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> 
            <span class="s2">&quot;_Riser_instance_structure.npy&quot;</span>
        <span class="p">)</span>
        
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span>
            <span class="n">save_str</span><span class="p">,</span>
            <span class="n">riser_npy</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Riser.build_Riser_instance_dataframe"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.build_Riser_instance_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">build_Riser_instance_dataframe</span><span class="p">(</span>
        <span class="bp">self</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a pandas dataframe containing data attributes of the Riser </span>
<span class="sd">        class instance. Only contains data that is stored as single string or</span>
<span class="sd">        numeric values for each profile. </span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            None</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            df: pd.DataFrame</span>
<span class="sd">                Output dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># UPDATE THESE IF NEW TYPES ARE INTRODUCED</span>
        <span class="c1"># unwanted datatypes:</span>
        <span class="n">no_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">dict</span><span class="p">,</span> 
            <span class="nb">list</span><span class="p">,</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">OptimizeResult</span> <span class="c1"># from scipy</span>
        <span class="p">]</span>

        <span class="c1"># get all attributes that are not methods, or __NAME__</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> 
              <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> 
              <span class="ow">and</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))]</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="c1"># if the attribute contains numbers or strings, save to df</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">==</span> <span class="n">nrows</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">no_types</span><span class="p">):</span> 
                <span class="n">df</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>
            
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="Riser.plot_profile_map"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.Riser.plot_profile_map">[docs]</a>    <span class="k">def</span> <span class="nf">plot_profile_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rasterpath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">band_no</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">diffusion_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">dem_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
        <span class="n">dem_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">410</span><span class="p">,</span>
        <span class="n">annotate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to plot profiles onto a DEM (must have the same projection!).</span>
<span class="sd">        Plot lines are colored according to kt (linear or nonlinear).</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">            rasterpath: str</span>
<span class="sd">                Subdirectory and filename of the DEM</span>
<span class="sd">            band_no: int</span>
<span class="sd">                Number of band containing elevations. Default is 1.</span>
<span class="sd">            diffusion_type: str</span>
<span class="sd">                &quot;linear&quot; or &quot;nonlinear&quot;, decides the kt to use to color</span>
<span class="sd">                profiles on the map.</span>
<span class="sd">            dem_min: float</span>
<span class="sd">                Lower limit of the color map.</span>
<span class="sd">            dem_max: float</span>
<span class="sd">                Upper limit of the color map.</span>
<span class="sd">            annotate: bool</span>
<span class="sd">                Whether to display profile names on the map.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">raster</span> <span class="o">=</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">+</span><span class="n">rasterpath</span><span class="p">)</span>
        <span class="n">dem</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">band_no</span><span class="p">)</span>
        <span class="n">raster_bounds</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">raster_bounds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">raster_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">fg</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">dem</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">raster_bounds</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
            <span class="n">vmin</span><span class="o">=</span><span class="n">dem_min</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">dem_max</span><span class="p">)</span>
        <span class="c1"># choose the kt to use:</span>
        <span class="k">if</span> <span class="n">diffusion_type</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">kt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_kt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonlin_best_t</span><span class="p">)</span>
        <span class="c1"># normalize kt</span>
        <span class="n">norm_kt</span> <span class="o">=</span> <span class="p">(</span><span class="n">kt</span><span class="o">-</span><span class="n">kt</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">kt</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">kt</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">(</span><span class="n">norm_kt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">norm_kt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">norm_kt</span><span class="p">):</span>
            <span class="c1"># plot line:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># add label with age</span>
            <span class="c1"># calculate rotation angle to align with</span>
            <span class="k">if</span> <span class="n">annotate</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">kt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">rotation</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
                    <span class="n">verticalalignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span>
                <span class="p">)</span>
        <span class="c1"># add colorbar</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;jet&quot;</span><span class="p">),</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">kt</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">kt</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="n">sm</span><span class="o">.</span><span class="n">set_array</span><span class="p">([])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;kt$_</span><span class="si">{lin}</span><span class="s2">$ [m$^2$]&quot;</span> \
            <span class="k">if</span> <span class="n">diffusion_type</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span> \
            <span class="k">else</span> <span class="sa">r</span><span class="s2">&quot;kt$_</span><span class="si">{nl}</span><span class="s2">$ [m$^2$]&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>

<span class="c1">##############################################</span>
<span class="c1">## Part 3: loading a saved riser instance ##</span>
<span class="c1">##############################################</span>

<div class="viewcode-block" id="load_Riser_instance_structure"><a class="viewcode-back" href="../../riserfit.html#riserfit.profiles.load_Riser_instance_structure">[docs]</a><span class="k">def</span> <span class="nf">load_Riser_instance_structure</span><span class="p">(</span>
    <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Riser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function loads a Riser instance from a ``.npy`` file.</span>
<span class="sd">    The Riser attributes saved in the file should be in the form of a</span>
<span class="sd">    dict. ``riserfit.save_Riser_instance_structure()``</span>
<span class="sd">    outputs a format that can be read by this function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        filepath: str</span>
<span class="sd">            Path to subdirectory and ``.npy`` file.</span>
<span class="sd">        identifier: str</span>
<span class="sd">            An optional Riser instance identifier,</span>
<span class="sd">            set as the Riser.identifier. If &quot;&quot;, the identifier</span>
<span class="sd">            of the created instance is chosen from </span>
<span class="sd">            the ``.npy`` Riser instance.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        riser: class</span>
<span class="sd">            Instance of the Riser class.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">riser_npy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="si">}</span><span class="se">\\</span><span class="si">{</span><span class="n">filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># re-form to dict:</span>
    <span class="n">riser_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">riser_npy</span><span class="p">):</span>
        <span class="n">riser_dict</span><span class="p">[</span><span class="n">riser_npy</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span> <span class="o">=</span> <span class="n">riser_npy</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ind</span> <span class="o">+=</span> <span class="mi">2</span>

    <span class="n">inits</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;identifier&quot;</span><span class="p">]</span>
    <span class="n">riser</span> <span class="o">=</span> <span class="n">Riser</span><span class="p">(</span>
        <span class="n">riser_dict</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
        <span class="n">riser_dict</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span>
        <span class="n">riser_dict</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">],</span>
        <span class="n">riser_dict</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">],</span>
        <span class="n">riser_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
        <span class="n">identifier</span> <span class="k">if</span> <span class="n">identifier</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="n">riser_dict</span><span class="p">[</span><span class="s2">&quot;identifier&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">riser_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inits</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">riser</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">riser</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Lennart Grimm.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>